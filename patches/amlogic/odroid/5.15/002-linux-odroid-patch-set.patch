diff -Naur a/arch/arm64/include/asm/system_misc.h b/arch/arm64/include/asm/system_misc.h
--- a/arch/arm64/include/asm/system_misc.h	2021-10-18 02:00:13.000000000 -0400
+++ b/arch/arm64/include/asm/system_misc.h	2021-10-19 00:24:08.000000000 -0400
@@ -32,6 +32,8 @@
 struct mm_struct;
 extern void __show_regs(struct pt_regs *);
 
+extern void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
+
 #endif	/* __ASSEMBLY__ */
 
 #endif	/* __ASM_SYSTEM_MISC_H */
diff -Naur a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
--- a/arch/arm64/kernel/process.c	2021-10-18 02:00:13.000000000 -0400
+++ b/arch/arm64/kernel/process.c	2021-10-19 00:24:08.000000000 -0400
@@ -67,6 +67,8 @@
 void (*pm_power_off)(void);
 EXPORT_SYMBOL_GPL(pm_power_off);
 
+void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
+
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
 {
@@ -137,7 +139,10 @@
 		efi_reboot(reboot_mode, NULL);
 
 	/* Now call the architecture specific reboot code. */
-	do_kernel_restart(cmd);
+	if (arm_pm_restart)
+		arm_pm_restart(reboot_mode, cmd);
+	else
+		do_kernel_restart(cmd);
 
 	/*
 	 * Whoops - the architecture was unable to reboot.
diff -Naur a/drivers/gpu/drm/meson/Makefile b/drivers/gpu/drm/meson/Makefile
--- a/drivers/gpu/drm/meson/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-only
-meson-drm-y := meson_drv.o meson_plane.o meson_crtc.o meson_venc_cvbs.o
+meson-drm-y := meson_drv.o meson_plane.o meson_cursor.o meson_crtc.o meson_venc_cvbs.o
 meson-drm-y += meson_viu.o meson_vpp.o meson_venc.o meson_vclk.o meson_overlay.o
 meson-drm-y += meson_rdma.o meson_osd_afbcd.o
 
diff -Naur a/drivers/gpu/drm/meson/meson_crtc.c b/drivers/gpu/drm/meson/meson_crtc.c
--- a/drivers/gpu/drm/meson/meson_crtc.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_crtc.c	2021-10-19 00:24:08.000000000 -0400
@@ -36,6 +36,7 @@
 	struct drm_pending_vblank_event *event;
 	struct meson_drm *priv;
 	void (*enable_osd1)(struct meson_drm *priv);
+	void (*enable_osd2)(struct meson_drm *priv);
 	void (*enable_vd1)(struct meson_drm *priv);
 	void (*enable_osd1_afbc)(struct meson_drm *priv);
 	void (*disable_osd1_afbc)(struct meson_drm *priv);
@@ -110,6 +111,20 @@
 	writel_relaxed(0 << 16 |
 			(crtc_state->mode.vdisplay - 1),
 			priv->io_base + _REG(VPP_OSD1_BLD_V_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.hdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_H_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.vdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_V_SCOPE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
 	writel_relaxed(crtc_state->mode.hdisplay << 16 |
 			crtc_state->mode.vdisplay,
 			priv->io_base + _REG(VPP_OUT_H_V_SIZE));
@@ -158,6 +173,9 @@
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
@@ -183,11 +201,14 @@
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
 	/* Disable VPP Postblend */
-	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_VD1_POSTBLEND |
+	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND | VPP_VD1_POSTBLEND |
 			    VPP_VD1_PREBLEND | VPP_POSTBLEND_ENABLE, 0,
 			    priv->io_base + _REG(VPP_MISC));
 
@@ -223,6 +244,7 @@
 	struct meson_drm *priv = meson_crtc->priv;
 
 	priv->viu.osd1_commit = true;
+	priv->viu.osd2_commit = true;
 	priv->viu.vd1_commit = true;
 }
 
@@ -246,6 +268,12 @@
 			    priv->io_base + _REG(VPP_MISC));
 }
 
+static void meson_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_bits_relaxed(VPP_OSD2_POSTBLEND, VPP_OSD2_POSTBLEND,
+			    priv->io_base + _REG(VPP_MISC));
+}
+
 static void meson_crtc_g12a_enable_osd1_afbc(struct meson_drm *priv)
 {
 	writel_relaxed(priv->viu.osd1_blk2_cfg4,
@@ -274,14 +302,20 @@
 	writel_relaxed(priv->viu.osd_blend_din0_scope_v,
 		       priv->io_base +
 		       _REG(VIU_OSD_BLEND_DIN0_SCOPE_V));
-	writel_relaxed(priv->viu.osb_blend0_size,
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD1, OSD_BLEND_POSTBLD_SRC_OSD1,
+			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+}
+
+static void meson_g12a_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_relaxed(priv->viu.osd_blend_din3_scope_h,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
-	writel_relaxed(priv->viu.osb_blend1_size,
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_H));
+	writel_relaxed(priv->viu.osd_blend_din3_scope_v,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
-	writel_bits_relaxed(3 << 8, 3 << 8,
-			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_V));
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, OSD_BLEND_POSTBLD_SRC_OSD2,
+			    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
 }
 
 static void meson_crtc_enable_vd1(struct meson_drm *priv)
@@ -388,6 +422,43 @@
 		priv->viu.osd1_commit = false;
 	}
 
+	if (priv->viu.osd2_enabled && priv->viu.osd2_commit) {
+		writel_relaxed(priv->viu.osd2_ctrl_stat,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT));
+		writel_relaxed(priv->viu.osd2_ctrl_stat2,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[0],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[1],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W1));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[2],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[3],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W3));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[4],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W4));
+
+		/* vsync forced to update INTERLACE_SEL_ODD in interlace mode */
+		meson_crtc->vsync_forced = priv->viu.osd2_interlace;
+
+		meson_canvas_config(priv->canvas, priv->canvas_id_osd2,
+				priv->viu.osd2_addr,
+				priv->viu.osd2_stride,
+				priv->viu.osd2_height,
+				MESON_CANVAS_WRAP_NONE,
+				MESON_CANVAS_BLKMODE_LINEAR, 0);
+
+		/* Enable OSD2 */
+		if (meson_crtc->enable_osd2)
+			meson_crtc->enable_osd2(priv);
+
+		priv->viu.osd2_commit = false;
+	} else if (priv->viu.osd2_enabled && priv->viu.osd2_interlace) {
+		u32 reg = readl_relaxed(priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0)) & ~BIT(0);
+		writel_relaxed(reg | meson_venci_get_field(priv) ? 1 : 0,
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+	}
+
 	/* Update the VD1 registers */
 	if (priv->viu.vd1_enabled && priv->viu.vd1_commit) {
 
@@ -685,7 +756,7 @@
 	meson_crtc->priv = priv;
 	crtc = &meson_crtc->base;
 	ret = drm_crtc_init_with_planes(priv->drm, crtc,
-					priv->primary_plane, NULL,
+					priv->primary_plane, priv->cursor_plane,
 					&meson_crtc_funcs, "meson_crtc");
 	if (ret) {
 		dev_err(priv->drm->dev, "Failed to init CRTC\n");
@@ -694,6 +765,7 @@
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_crtc->enable_osd1 = meson_g12a_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_g12a_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_g12a_crtc_enable_vd1;
 		meson_crtc->viu_offset = MESON_G12A_VIU_OFFSET;
 		meson_crtc->enable_osd1_afbc =
@@ -703,6 +775,7 @@
 		drm_crtc_helper_add(crtc, &meson_g12a_crtc_helper_funcs);
 	} else {
 		meson_crtc->enable_osd1 = meson_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_crtc_enable_vd1;
 		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM)) {
 			meson_crtc->enable_osd1_afbc =
diff -Naur a/drivers/gpu/drm/meson/meson_cursor.c b/drivers/gpu/drm/meson/meson_cursor.c
--- a/drivers/gpu/drm/meson/meson_cursor.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_cursor.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#include <linux/bitfield.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "meson_cursor.h"
+#include "meson_registers.h"
+#include "meson_viu.h"
+
+struct meson_cursor {
+	struct drm_plane base;
+	struct meson_drm *priv;
+};
+#define to_meson_cursor(x) container_of(x, struct meson_cursor, base)
+
+static int meson_cursor_atomic_check(struct drm_plane *plane,
+				    struct drm_atomic_state *state)
+{
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+										 plane);
+	struct drm_crtc_state *crtc_state;
+
+	if (!new_plane_state->crtc)
+		return 0;
+
+	crtc_state = drm_atomic_get_crtc_state(state,
+					       new_plane_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	return drm_atomic_helper_check_plane_state(new_plane_state,
+						   crtc_state,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   true, true);
+}
+
+/* Takes a fixed 16.16 number and converts it to integer. */
+static inline int64_t fixed16_to_int(int64_t value)
+{
+	return value >> 16;
+}
+
+static void meson_cursor_atomic_update(struct drm_plane *plane,
+				      struct drm_atomic_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,
+									   plane);
+	struct drm_rect dest = drm_plane_state_dest(new_state);
+	struct meson_drm *priv = meson_cursor->priv;
+	struct drm_framebuffer *fb = new_state->fb;
+	struct drm_gem_cma_object *gem;
+	unsigned long flags;
+	int dst_w, dst_h;
+
+	/*
+	 * Update Coordinates
+	 * Update Formats
+	 * Update Buffer
+	 * Enable Plane
+	 */
+	spin_lock_irqsave(&priv->drm->event_lock, flags);
+
+	/* Enable OSD and BLK0, set max global alpha */
+	priv->viu.osd2_ctrl_stat = OSD_ENABLE |
+				   (0xFF << OSD_GLOBAL_ALPHA_SHIFT) |
+				   OSD_BLK0_ENABLE;
+
+	priv->viu.osd2_ctrl_stat2 = readl(priv->io_base +
+					  _REG(VIU_OSD2_CTRL_STAT2));
+
+	/* Set up BLK0 to point to the right canvas */
+	priv->viu.osd2_blk0_cfg[0] = priv->canvas_id_osd2 << OSD_CANVAS_SEL;
+	priv->viu.osd2_blk0_cfg[0] |= OSD_ENDIANNESS_LE;
+
+	/* On GXBB, Use the old non-HDR RGB2YUV converter */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+		priv->viu.osd2_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ARGB;
+		break;
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ABGR;
+		break;
+	case DRM_FORMAT_RGB888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_24 |
+			OSD_COLOR_MATRIX_24_RGB;
+		break;
+	case DRM_FORMAT_RGB565:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_16 |
+			OSD_COLOR_MATRIX_16_RGB565;
+		break;
+	}
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+		/* For XRGB, replace the pixel's alpha by 0xFF */
+		priv->viu.osd2_ctrl_stat2 |= OSD_REPLACE_EN;
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+		/* For ARGB, use the pixel's alpha */
+		priv->viu.osd2_ctrl_stat2 &= ~OSD_REPLACE_EN;
+		break;
+	}
+
+	dst_w = new_state->crtc_w;
+	dst_h = new_state->crtc_h;
+
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
+		priv->viu.osd2_interlace = true;
+	else
+		priv->viu.osd2_interlace = false;
+
+	/*
+	 * The format of these registers is (x2 << 16 | x1),
+	 * where x2 is exclusive.
+	 * e.g. +30x1920 would be (1919 << 16) | 30
+	 */
+	priv->viu.osd2_blk0_cfg[1] =
+				((fixed16_to_int(new_state->src.x2) - 1) << 16) |
+				fixed16_to_int(new_state->src.x1);
+	priv->viu.osd2_blk0_cfg[2] =
+				((fixed16_to_int(new_state->src.y2) - 1) << 16) |
+				fixed16_to_int(new_state->src.y1);
+	priv->viu.osd2_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;
+	priv->viu.osd2_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		priv->viu.osd_blend_din3_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
+		priv->viu.osd_blend_din3_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
+		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
+	}
+
+	/* Update Canvas with buffer address */
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
+	priv->viu.osd2_addr = gem->paddr;
+	priv->viu.osd2_stride = fb->pitches[0];
+	priv->viu.osd2_height = fb->height;
+	priv->viu.osd2_width = fb->width;
+
+	/* TOFIX: Reset OSD2 before enabling it on GXL+ SoCs ? */
+
+	priv->viu.osd2_enabled = true;
+
+	spin_unlock_irqrestore(&priv->drm->event_lock, flags);
+}
+
+static void meson_cursor_atomic_disable(struct drm_plane *plane,
+				       struct drm_atomic_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct meson_drm *priv = meson_cursor->priv;
+
+	/* Disable OSD2 */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, 0,
+				    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
+	else
+		writel_bits_relaxed(VPP_OSD2_POSTBLEND, 0,
+				    priv->io_base + _REG(VPP_MISC));
+
+	priv->viu.osd2_enabled = false;
+}
+
+static const struct drm_plane_helper_funcs meson_cursor_helper_funcs = {
+	.atomic_check	= meson_cursor_atomic_check,
+	.atomic_disable	= meson_cursor_atomic_disable,
+	.atomic_update	= meson_cursor_atomic_update,
+};
+
+static const struct drm_plane_funcs meson_cursor_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+};
+
+static const uint32_t supported_drm_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+};
+
+static const uint64_t format_modifiers_default[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID,
+};
+
+int meson_cursor_create(struct meson_drm *priv)
+{
+	struct meson_cursor *meson_cursor;
+	struct drm_plane *cursor;
+
+	meson_cursor = devm_kzalloc(priv->drm->dev, sizeof(*meson_cursor),
+				   GFP_KERNEL);
+	if (!meson_cursor)
+		return -ENOMEM;
+
+	meson_cursor->priv = priv;
+	cursor = &meson_cursor->base;
+
+	drm_universal_plane_init(priv->drm, cursor, 0xFF,
+				 &meson_cursor_funcs,
+				 supported_drm_formats,
+				 ARRAY_SIZE(supported_drm_formats),
+				 format_modifiers_default,
+				 DRM_PLANE_TYPE_CURSOR, "meson_cursor_plane");
+
+	drm_plane_helper_add(cursor, &meson_cursor_helper_funcs);
+
+	/* For now, OSD Cursor is always on top of the primary plane */
+	drm_plane_create_zpos_immutable_property(cursor, 2);
+
+	priv->cursor_plane = cursor;
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_cursor.h b/drivers/gpu/drm/meson/meson_cursor.h
--- a/drivers/gpu/drm/meson/meson_cursor.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/meson/meson_cursor.h	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_CURSOR_H
+#define __MESON_CURSOR_H
+
+#include "meson_drv.h"
+
+int meson_cursor_create(struct meson_drm *priv);
+
+#endif /* __MESON_CURSOR_H */
diff -Naur a/drivers/gpu/drm/meson/meson_drv.c b/drivers/gpu/drm/meson/meson_drv.c
--- a/drivers/gpu/drm/meson/meson_drv.c	2022-10-26 06:35:57.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_drv.c	2022-10-26 10:57:39.820573081 -0400
@@ -29,6 +29,7 @@
 #include "meson_drv.h"
 #include "meson_overlay.h"
 #include "meson_plane.h"
+#include "meson_cursor.h"
 #include "meson_osd_afbcd.h"
 #include "meson_registers.h"
 #include "meson_venc_cvbs.h"
@@ -247,6 +248,9 @@
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd1);
 	if (ret)
 		goto free_drm;
+	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd2);
+	if (ret)
+		goto free_drm;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_0);
 	if (ret) {
 		meson_canvas_free(priv->canvas, priv->canvas_id_osd1);
@@ -326,6 +330,10 @@
 	if (ret)
 		goto exit_afbcd;
 
+	ret = meson_cursor_create(priv);
+	if (ret)
+		goto free_drm;
+
 	ret = meson_plane_create(priv);
 	if (ret)
 		goto exit_afbcd;
@@ -475,17 +483,6 @@
 	return count;
 }
 
-static void meson_drv_shutdown(struct platform_device *pdev)
-{
-	struct meson_drm *priv = dev_get_drvdata(&pdev->dev);
-
-	if (!priv)
-		return;
-
-	drm_kms_helper_poll_fini(priv->drm);
-	drm_atomic_helper_shutdown(priv->drm);
-}
-
 static int meson_drv_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
@@ -565,7 +562,6 @@
 static struct platform_driver meson_drm_platform_driver = {
 	.probe      = meson_drv_probe,
 	.remove     = meson_drv_remove,
-	.shutdown   = meson_drv_shutdown,
 	.driver     = {
 		.name	= "meson-drm",
 		.of_match_table = dt_match,
diff -Naur a/drivers/gpu/drm/meson/meson_drv.h b/drivers/gpu/drm/meson/meson_drv.h
--- a/drivers/gpu/drm/meson/meson_drv.h	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_drv.h	2021-10-19 00:24:08.000000000 -0400
@@ -43,12 +43,14 @@
 
 	struct meson_canvas *canvas;
 	u8 canvas_id_osd1;
+	u8 canvas_id_osd2;
 	u8 canvas_id_vd1_0;
 	u8 canvas_id_vd1_1;
 	u8 canvas_id_vd1_2;
 
 	struct drm_device *drm;
 	struct drm_crtc *crtc;
+	struct drm_plane *cursor_plane;
 	struct drm_plane *primary_plane;
 	struct drm_plane *overlay_plane;
 
@@ -82,6 +84,21 @@
 		uint32_t osd_blend_din0_scope_h;
 		uint32_t osd_blend_din0_scope_v;
 		uint32_t osb_blend0_size;
+
+		bool osd2_enabled;
+		bool osd2_interlace;
+		bool osd2_commit;
+		uint32_t osd2_ctrl_stat;
+		uint32_t osd2_ctrl_stat2;
+		uint32_t osd2_blk0_cfg[5];
+		uint32_t osd2_blk1_cfg4;
+		uint32_t osd2_blk2_cfg4;
+		uint32_t osd2_addr;
+		uint32_t osd2_stride;
+		uint32_t osd2_height;
+		uint32_t osd2_width;
+		uint32_t osd_blend_din3_scope_h;
+		uint32_t osd_blend_din3_scope_v;
 		uint32_t osb_blend1_size;
 
 		bool vd1_enabled;
diff -Naur a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
--- a/drivers/gpu/drm/meson/meson_plane.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_plane.c	2021-10-19 00:24:08.000000000 -0400
@@ -360,7 +360,6 @@
 		priv->viu.osd_blend_din0_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
 		priv->viu.osd_blend_din0_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
 		priv->viu.osb_blend0_size = dst_h << 16 | dst_w;
-		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
 	}
 
 	/* Update Canvas with buffer address */
diff -Naur a/drivers/gpu/drm/meson/meson_registers.h b/drivers/gpu/drm/meson/meson_registers.h
--- a/drivers/gpu/drm/meson/meson_registers.h	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_registers.h	2021-10-19 00:24:08.000000000 -0400
@@ -634,11 +634,6 @@
 #define VPP_WRAP_OSD3_MATRIX_PRE_OFFSET2 0x3dbc
 #define VPP_WRAP_OSD3_MATRIX_EN_CTRL 0x3dbd
 
-/* osd1 HDR */
-#define OSD1_HDR2_CTRL 0x38a0
-#define OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN       BIT(13)
-#define OSD1_HDR2_CTRL_REG_ONLY_MAT            BIT(16)
-
 /* osd2 scaler */
 #define OSD2_VSC_PHASE_STEP 0x3d00
 #define OSD2_VSC_INI_PHASE 0x3d01
diff -Naur a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
--- a/drivers/gpu/drm/meson/meson_vclk.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_vclk.c	2021-10-19 00:24:08.000000000 -0400
@@ -357,6 +357,8 @@
 	MESON_VCLK_HDMI_594000,
 /* 2970 /1 /1 /1 /5 /1  => /1 /2 */
 	MESON_VCLK_HDMI_594000_YUV420,
+/* 4830 /2 /1 /2 /5 /1  => /1 /1 */
+	MESON_VCLK_HDMI_241500,
 };
 
 struct meson_vclk_params {
@@ -467,6 +469,18 @@
 		.vid_pll_div = VID_PLL_DIV_5,
 		.vclk_div = 1,
 	},
+	[MESON_VCLK_HDMI_241500] = {
+		.pll_freq = 4830000,
+		.phy_freq = 2415000,
+		.venc_freq = 241500,
+		.vclk_freq = 241500,
+		.pixel_freq = 241500,
+		.pll_od1 = 2,
+		.pll_od2 = 1,
+		.pll_od3 = 2,
+		.vid_pll_div = VID_PLL_DIV_5,
+		.vclk_div = 1,
+	},
 	{ /* sentinel */ },
 };
 
@@ -873,6 +887,10 @@
 			m = 0xf7;
 			frac = vic_alternate_clock ? 0x8148 : 0x10000;
 			break;
+		case 4830000:
+			m = 0xc9;
+			frac = 0xd560;
+			break;
 		}
 
 		meson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);
diff -Naur a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
--- a/drivers/gpu/drm/meson/meson_venc.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_venc.c	2021-10-19 00:24:08.000000000 -0400
@@ -866,10 +866,11 @@
 			    DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))
 		return MODE_BAD;
 
-	if (mode->hdisplay < 640 || mode->hdisplay > 1920)
+	/* support higher resolution than 1920x1080 */
+	if (mode->hdisplay < 640 || mode->hdisplay > 2560)
 		return MODE_BAD_HVALUE;
 
-	if (mode->vdisplay < 480 || mode->vdisplay > 1200)
+	if (mode->vdisplay < 480 || mode->vdisplay > 1600)
 		return MODE_BAD_VVALUE;
 
 	return MODE_OK;
diff -Naur a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
--- a/drivers/gpu/drm/meson/meson_viu.c	2022-08-17 09:16:21.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_viu.c	2022-08-18 21:44:58.000000000 -0400
@@ -425,6 +425,7 @@
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
 	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
 		meson_viu_load_matrix(priv);
+#if 0
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_viu_set_g12a_osd1_matrix(priv, RGB709_to_YUV709l_coeff,
 					       true);
@@ -433,6 +434,7 @@
 				OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN, 0,
 				priv->io_base + _REG(OSD1_HDR2_CTRL));
 	}
+#endif
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
diff -Naur a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
--- a/drivers/gpu/drm/tiny/ili9341.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/tiny/ili9341.c	2021-10-19 00:24:08.000000000 -0400
@@ -162,12 +162,14 @@
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
diff -Naur a/drivers/gpu/drm/tiny/ili9488_pio.c b/drivers/gpu/drm/tiny/ili9488_pio.c
--- a/drivers/gpu/drm/tiny/ili9488_pio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/gpu/drm/tiny/ili9488_pio.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Hardkernel 3.5 ISP TFT display
+ *
+ * Copyright 2021 Dongjin Kim <tobetter@gmail.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+
+#define ILI9488_COLUMN_ADDR	0x2a
+#define ILI9488_PAGE_ADDR	0x2b
+#define ILI9488_MEMORY_WRITE	0x2c
+#define ILI9488_ITFCTR1         0xb0
+#define ILI9488_FRMCTR1		0xb1
+#define ILI9488_PWCTRL1         0xc2
+#define ILI9488_VMCTRL1         0xc5
+#define ILI9488_PGAMCTRL        0xe0
+#define ILI9488_NGAMCTRL        0xe1
+#define ILI9488_MADCTL_BGR      BIT(3)
+#define ILI9488_MADCTL_MV       BIT(5)
+#define ILI9488_MADCTL_MX       BIT(6)
+#define ILI9488_MADCTL_MY       BIT(7)
+
+struct ili9488_data {
+	struct mipi_dbi_dev *dbidev;
+	struct gpio_desc *wr;
+	struct gpio_desc *cs;
+	struct gpio_desc *db[8];
+	void __iomem *membase;
+	u32 mask;
+	u32 bits[8];
+	u32 bits_wr;
+};
+
+static struct ili9488_data *pdata;
+static u32 *rgb;
+
+static u32 ili9488_rgb565_to_gpiobus(struct ili9488_data *pdata, u8 color)
+{
+	int i;
+	u32 value = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (color & 1)
+			value |= pdata->bits[i];
+		else
+			value &= ~(pdata->bits[i]);
+		color >>= 1;
+	}
+
+	return value;
+}
+
+static int ili9488_bus_write(struct mipi_dbi *dbi, u8 data)
+{
+	int i;
+
+	if (pdata->membase) {
+		u32 v = (readl(pdata->membase) & ~pdata->mask) | *(rgb + data);
+		writel(v, pdata->membase);
+		writel(v | pdata->bits_wr, pdata->membase);
+		return 0;
+	}
+
+	gpiod_set_value(pdata->wr, 0);
+	for (i = 0; i < 8; i++) {
+		gpiod_set_value(pdata->db[i], data & 1);
+		data >>= 1;
+	}
+	gpiod_set_value(pdata->wr, 1);
+
+	return 0;
+}
+
+static int ili9488_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par, size_t num)
+{
+	u8 *p = par;
+
+	gpiod_set_value(dbi->dc, 0);
+	ili9488_bus_write(dbi, *cmd);
+	gpiod_set_value(dbi->dc, 1);
+
+	while (num--)
+		ili9488_bus_write(dbi, *p++);
+
+	return 0;
+}
+
+static void ili9488_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	gpiod_set_value(pdata->cs, 0);
+
+	mipi_dbi_command(dbi, ILI9488_ITFCTR1, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(250);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dbi_command(dbi, ILI9488_PWCTRL1, 0x33);
+	mipi_dbi_command(dbi, ILI9488_VMCTRL1, 0x00, 0x1e, 0x80, 0x00);
+	mipi_dbi_command(dbi, ILI9488_FRMCTR1, 0xb0, 0x11);
+	mipi_dbi_command(dbi, ILI9488_PGAMCTRL,
+			0x00, 0x04, 0x0e, 0x08, 0x17, 0x0a, 0x40, 0x79,
+			0x4d, 0x07, 0x0e, 0x0a, 0x1a, 0x1d, 0x0f);
+	mipi_dbi_command(dbi, ILI9488_NGAMCTRL,
+			0x00, 0x1b, 0x1f, 0x02, 0x10, 0x05, 0x32, 0x34,
+			0x43, 0x02, 0x0a, 0x09, 0x33, 0x37, 0x0f);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+ out_enable:
+	switch (dbidev->rotation) {
+		case 90:
+			addr_mode = ILI9488_MADCTL_MY;
+			break;
+		case 180:
+			addr_mode = ILI9488_MADCTL_MV;
+			break;
+		case 270:
+			addr_mode = ILI9488_MADCTL_MX;
+			break;
+		default:
+			addr_mode = ILI9488_MADCTL_MV | ILI9488_MADCTL_MY |
+				ILI9488_MADCTL_MX;
+			break;
+	}
+
+	addr_mode |= ILI9488_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9488_pipe_funcs = {
+	.enable = ili9488_pipe_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9488_mode = {
+	DRM_SIMPLE_MODE(480, 320, 73, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9488_fops);
+
+static struct drm_driver ili9488_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9488_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.name			= "ili9488",
+	.desc			= "Ilitek ILI9488",
+	.date			= "20210201",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int ili9488_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct mipi_dbi *dbi;
+	struct drm_device *drm;
+	struct mipi_dbi_dev *dbidev;
+	int ret;
+	int i;
+	u32 rotation = 0;
+	struct resource res;
+	char str[32];
+
+	pdata = devm_kzalloc(dev, sizeof(struct ili9488_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	dbidev = devm_drm_dev_alloc(dev, &ili9488_driver,
+			struct mipi_dbi_dev, drm);
+	if (IS_ERR(dbidev))
+		return PTR_ERR(dbidev);
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dbi->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dbi->dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dbi->dc);
+	}
+
+	pdata->wr = devm_gpiod_get(dev, "wr", GPIOD_OUT_HIGH);
+	if (IS_ERR(pdata->wr)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'wr'\n");
+		return PTR_ERR(pdata->wr);
+	}
+
+	pdata->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->cs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'cs'\n");
+		return PTR_ERR(pdata->cs);
+	}
+
+	for (i = 0; i < 8; i++) {
+		struct gpio_desc *desc;
+		int gpio = of_get_named_gpio(np, "db-gpios", i);
+		if (gpio < 0)
+			break;	/* FIXME */
+
+		desc = gpio_to_desc(gpio);
+
+		devm_gpio_request(dev, gpio, NULL);
+		gpiod_direction_output(desc, 1);
+
+		pdata->db[i] = desc;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (!ret) {
+		pdata->membase = devm_ioremap(dev, res.start,
+				resource_size(&res));
+		if (!IS_ERR(pdata->membase)) {
+			for (i = 0; i < 8; i++) {
+				sprintf(str, "db-bits-%d", i);
+				ret = of_property_read_u32(np, str,
+						&pdata->bits[i]);
+				if (ret)
+					continue;
+				pdata->mask |= pdata->bits[i];
+			}
+
+			ret = of_property_read_u32(np, "db-bits-wr",
+					&pdata->bits_wr);
+			if (!ret)
+				pdata->mask |= pdata->bits_wr;
+		}
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	rgb = devm_kzalloc(dev, sizeof(u32) * 256, GFP_KERNEL);
+	if (rgb) {
+		u32 *p = rgb;
+		for (i = 0; i < 256; i++)
+			*p++ = ili9488_rgb565_to_gpiobus(pdata, i);
+	}
+
+	gpiod_set_value(pdata->wr, 1);
+	gpiod_set_value(dbi->dc, 0);
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9488_command;
+	dbi->read_commands = NULL;
+	dbi->swap_bytes = true;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9488_pipe_funcs,
+			&ili9488_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, pdata);
+	pdata->dbidev = dbidev;
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9488_remove(struct platform_device *pdev)
+{
+	struct ili9488_data *pdata = platform_get_drvdata(pdev);
+	struct mipi_dbi_dev *dbidev = pdata->dbidev;
+	struct drm_device *drm = &dbidev->drm;
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static const struct of_device_id ili9488_dt_ids[] = {
+	{ .compatible = "ili9488", 0 },
+	{ .compatible = "hardkernel,ili9488", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, ili9488_dt_ids);
+
+static struct platform_driver ili9488_platform_driver = {
+	.driver = {
+		.name = "ili9488",
+		.of_match_table = ili9488_dt_ids,
+	},
+	.probe = ili9488_probe,
+	.remove = ili9488_remove,
+};
+
+static int __init ili9488_init(void)
+{
+	return platform_driver_register(&ili9488_platform_driver);
+}
+
+static void __exit ili9488_exit(void)
+{
+	platform_driver_unregister(&ili9488_platform_driver);
+}
+
+module_init(ili9488_init);
+module_exit(ili9488_exit);
+
+MODULE_DESCRIPTION("Ilitek ILI9488 DRM driver (8bit PIO mode)");
+MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
--- a/drivers/gpu/drm/tiny/Kconfig	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/tiny/Kconfig	2021-10-19 00:24:08.000000000 -0400
@@ -119,6 +119,19 @@
 
 	  If M is selected the module will be called ili9486.
 
+config TINYDRM_ILI9488_PIO
+	tristate "DRM support for ILI9488 display panels (8bit PIO)"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for th following Ilitek ILI9488 panels:
+          * Hardkernel 3.5" 480x320 TFT (HKTFT 3.5")
+
+	  If M is selected the module will be called hktft35.
+
 config TINYDRM_MI0283QT
 	tristate "DRM support for MI0283QT"
 	depends on DRM && SPI
diff -Naur a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
--- a/drivers/gpu/drm/tiny/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/gpu/drm/tiny/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -9,6 +9,7 @@
 obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
 obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
 obj-$(CONFIG_TINYDRM_ILI9486)		+= ili9486.o
+obj-$(CONFIG_TINYDRM_ILI9488_PIO)	+= ili9488_pio.o
 obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
diff -Naur a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
--- a/drivers/hid/hid-ids.h	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/hid/hid-ids.h	2021-10-19 00:24:08.000000000 -0400
@@ -1353,4 +1353,10 @@
 #define USB_VENDOR_ID_SIGNOTEC			0x2133
 #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
 
+#define USB_DEVICE_ID_DWAV_MULTITOUCH	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define USB_DEVICE_ID_VU5	0x0704
+#define USB_DEVICE_ID_VU7PLUS	0x0705
+
 #endif
diff -Naur a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
--- a/drivers/hid/hid-quirks.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/hid/hid-quirks.c	2021-10-19 00:24:08.000000000 -0400
@@ -861,6 +861,10 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
 #endif
 	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_DWAV, USB_DEVICE_ID_DWAV_MULTITOUCH) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS) },
 	{ }
 };
 
diff -Naur a/drivers/hwmon/pwm-fan.c b/drivers/hwmon/pwm-fan.c
--- a/drivers/hwmon/pwm-fan.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/hwmon/pwm-fan.c	2021-10-19 00:24:08.000000000 -0400
@@ -8,6 +8,7 @@
  */
 
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -44,6 +45,7 @@
 	unsigned int pwm_fan_max_state;
 	unsigned int *pwm_fan_cooling_levels;
 	struct thermal_cooling_device *cdev;
+	int enable;
 
 	struct hwmon_chip_info info;
 	struct hwmon_channel_info fan_channel;
@@ -99,6 +101,10 @@
 	struct pwm_state *state = &ctx->pwm_state;
 
 	mutex_lock(&ctx->lock);
+
+	if (!ctx->enable)
+		pwm = MAX_PWM;
+
 	if (ctx->pwm_value == pwm)
 		goto exit_set_pwm_err;
 
@@ -183,6 +189,51 @@
 	.write = pwm_fan_write,
 };
 
+static ssize_t enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+	int err;
+	unsigned long val;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
+
+	mutex_lock(&ctx->lock);
+	ctx->enable = val;
+	mutex_unlock(&ctx->lock);
+
+	err = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[ctx->pwm_fan_state]);
+
+	return err ? err : count;
+}
+
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ctx->enable);
+}
+
+static SENSOR_DEVICE_ATTR_RW(pwm1_enable, enable, 0);
+
+static struct attribute *pwm_fan_attrs[] = {
+	&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group pwm_fan_group = {
+	.attrs = pwm_fan_attrs,
+};
+
+static const struct attribute_group *pwm_fan_groups[] = {
+	&pwm_fan_group,
+	NULL,
+};
+
 /* thermal cooling device callbacks */
 static int pwm_fan_get_max_state(struct thermal_cooling_device *cdev,
 				 unsigned long *state)
@@ -214,7 +265,7 @@
 pwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)
 {
 	struct pwm_fan_ctx *ctx = cdev->devdata;
-	int ret;
+	int ret = 0;
 
 	if (!ctx || (state > ctx->pwm_fan_max_state))
 		return -EINVAL;
@@ -222,10 +273,12 @@
 	if (state == ctx->pwm_fan_state)
 		return 0;
 
-	ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
-	if (ret) {
-		dev_err(&cdev->device, "Cannot set pwm!\n");
-		return ret;
+	if (ctx->enable >= 2) {
+		ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
+		if (ret) {
+			dev_err(&cdev->device, "Cannot set pwm!\n");
+			return ret;
+		}
 	}
 
 	ctx->pwm_fan_state = state;
@@ -316,6 +369,8 @@
 	if (IS_ERR(ctx->pwm))
 		return dev_err_probe(dev, PTR_ERR(ctx->pwm), "Could not get PWM\n");
 
+	ctx->enable = 2;
+
 	platform_set_drvdata(pdev, ctx);
 
 	ctx->reg_en = devm_regulator_get_optional(dev, "fan");
@@ -436,7 +491,7 @@
 	ctx->info.info = channels;
 
 	hwmon = devm_hwmon_device_register_with_info(dev, "pwmfan",
-						     ctx, &ctx->info, NULL);
+						     ctx, &ctx->info, pwm_fan_groups);
 	if (IS_ERR(hwmon)) {
 		dev_err(dev, "Failed to register hwmon device\n");
 		return PTR_ERR(hwmon);
diff -Naur a/drivers/input/touchscreen/dwav-usb-mt.c b/drivers/input/touchscreen/dwav-usb-mt.c
--- a/drivers/input/touchscreen/dwav-usb-mt.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/input/touchscreen/dwav-usb-mt.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,554 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * D-WAV Scientific USB(HID) MultiTouch Screen Driver(Based on usbtouchscreen.c)
+ *
+ * Copyright (C) Hardkernel, 2015
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+
+#include <linux/input/mt.h>
+
+#define USB_VENDOR_ID_DWAV	0x0eef	/* 800 x 480, 7" DWAV touch */
+#define USB_DEVICE_ID_VU7	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define	USB_DEVICE_ID_VU5	0x0704
+#define	USB_DEVICE_ID_VU7PLUS	0x0705
+
+enum	{
+	ODROID_VU7 = 0,	/* 800 x 480, 7" Touch */
+	ODROID_VU5,	/* 800 x 480, 5" Touch */
+	ODROID_VU7PLUS,	/* 1024 x 600, 7" Touch */
+};
+
+struct usbtouch_device_info	{
+	char	name[64];
+	int	max_x;
+	int	max_y;
+	int	max_press;
+	int	max_finger;
+};
+
+const struct usbtouch_device_info DEV_INFO[] = {
+	[ODROID_VU7] = {
+		.name = "ODROID VU7 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU5] = {
+		.name = "ODROID VU5 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU7PLUS] = {
+		.name = "ODROID VU7 Plus MultiTouch(1024x600)",
+		.max_x = 1024,
+		.max_y = 600,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+};
+
+static const struct usb_device_id dwav_usb_mt_devices[] = {
+	{USB_DEVICE(USB_VENDOR_ID_DWAV,   USB_DEVICE_ID_VU7),
+		.driver_info = ODROID_VU7},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5),
+		.driver_info = ODROID_VU5},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS),
+		.driver_info = ODROID_VU7PLUS},
+	{}
+};
+
+struct dwav_raw {                   /* Total 25 bytes */
+	unsigned char   header;     /* frame header 0xAA*/
+	unsigned char   press;
+	/* Touch flag (1:valid touch data, 0:touch finished) */
+	unsigned short  x1;         /* 1st x */
+	unsigned short  y1;         /* 1st y */
+	unsigned char   end;
+	/* 1st touch finish flags 0xBB, RPI only uses the first 7 bytes */
+	unsigned char   ids;        /* touch ID(bit field) */
+	unsigned short  y2;
+	unsigned short  x2;
+	unsigned short  y3;
+	unsigned short  x3;
+	unsigned short  y4;
+	unsigned short  x4;
+	unsigned short  y5;
+	unsigned short  x5;
+	unsigned char   tail;       /* frame end 0xCC */
+};
+
+#define	TS_EVENT_UNKNOWN	0x00
+#define	TS_EVENT_PRESS		0x01
+#define	TS_EVENT_RELEASE	0x02
+
+struct	finger_t	{
+	unsigned int	status;	/* ts event type */
+	unsigned int	x;	/* ts data x */
+	unsigned int	y;	/* ts data y */
+}	__packed;
+
+struct dwav_usb_mt  {
+	char		name[128], phys[64];
+
+	int		dev_id;
+	/* for URB Data DMA */
+	dma_addr_t	data_dma;
+	unsigned char	*data;
+	int		data_size;
+
+	struct urb		*irq;
+	struct usb_interface	*interface;
+	struct input_dev	*input;
+
+	struct finger_t		*finger;
+};
+
+static void dwav_usb_mt_report(struct dwav_usb_mt *dwav_usb_mt)
+{
+	int	id, max_x, max_y, max_press, max_finger;
+
+	max_x = DEV_INFO[dwav_usb_mt->dev_id].max_x;
+	max_y = DEV_INFO[dwav_usb_mt->dev_id].max_y;
+	max_press = DEV_INFO[dwav_usb_mt->dev_id].max_press;
+	max_finger = DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+
+	for (id = 0; id < max_finger; id++)	{
+
+		if (dwav_usb_mt->finger[id].status == TS_EVENT_UNKNOWN)
+			continue;
+
+		if (dwav_usb_mt->finger[id].x >= max_x ||
+		    dwav_usb_mt->finger[id].y >= max_y)
+			continue;
+
+		input_mt_slot(dwav_usb_mt->input, id);
+
+		if (dwav_usb_mt->finger[id].status != TS_EVENT_RELEASE) {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, true);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_X,
+					dwav_usb_mt->finger[id].x);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_Y,
+					dwav_usb_mt->finger[id].y);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_PRESSURE,
+					max_press);
+		} else {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, false);
+			dwav_usb_mt->finger[id].status = TS_EVENT_UNKNOWN;
+		}
+		input_mt_report_pointer_emulation(dwav_usb_mt->input, true);
+		input_sync(dwav_usb_mt->input);
+	}
+}
+
+static void dwav_usb_mt_process(struct dwav_usb_mt *dwav_usb_mt,
+		unsigned char *pkt, int len)
+{
+	struct  dwav_raw *dwav_raw = (struct dwav_raw *)pkt;
+	unsigned char bit_mask, cnt;
+
+	for (cnt = 0, bit_mask = 0x01;
+	     cnt < DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+	     cnt++, bit_mask <<= 1) {
+		if ((dwav_raw->ids & bit_mask) && dwav_raw->press) {
+			dwav_usb_mt->finger[cnt].status = TS_EVENT_PRESS;
+			switch (cnt) {
+			case	0:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x1);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y1);
+				break;
+			case	1:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x2);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y2);
+				break;
+			case	2:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x3);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y3);
+				break;
+			case	3:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x4);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y4);
+				break;
+			case	4:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x5);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y5);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (dwav_usb_mt->finger[cnt].status == TS_EVENT_PRESS)
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_RELEASE;
+			else
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_UNKNOWN;
+		}
+	}
+	dwav_usb_mt_report(dwav_usb_mt);
+}
+
+static void dwav_usb_mt_irq(struct urb *urb)
+{
+	struct dwav_usb_mt *dwav_usb_mt = urb->context;
+	struct device *dev = &dwav_usb_mt->interface->dev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ETIME:
+		/* this urb is timing out */
+		dev_dbg(dev, "%s - urb timed out - was the device unplugged?\n",
+				__func__);
+		return;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EPIPE:
+		/* this urb is terminated, clean up */
+		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
+				__func__, urb->status);
+		return;
+	default:
+		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
+				__func__, urb->status);
+		goto exit;
+	}
+
+	dwav_usb_mt_process(dwav_usb_mt, dwav_usb_mt->data, urb->actual_length);
+
+exit:
+	usb_mark_last_busy(interface_to_usbdev(dwav_usb_mt->interface));
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval) {
+		dev_err(dev, "%s - usb_submit_urb failed with result: %d\n",
+				__func__, retval);
+	}
+}
+
+static int dwav_usb_mt_open(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	dwav_usb_mt->irq->dev = interface_to_usbdev(dwav_usb_mt->interface);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface) ? -EIO : 0;
+	if (r < 0)
+		goto out;
+
+	if (usb_submit_urb(dwav_usb_mt->irq, GFP_KERNEL)) {
+		r = -EIO;
+		goto out_put;
+	}
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 1;
+out_put:
+	usb_autopm_put_interface(dwav_usb_mt->interface);
+out:
+	return r;
+}
+
+static void dwav_usb_mt_close(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface);
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 0;
+	if (!r)
+		usb_autopm_put_interface(dwav_usb_mt->interface);
+}
+
+static int dwav_usb_mt_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	return 0;
+}
+
+static int dwav_usb_mt_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int result = 0;
+
+	mutex_lock(&input->mutex);
+	if (input->users)
+		result = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return result;
+}
+
+static int dwav_usb_mt_reset_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int err = 0;
+
+	/* restart IO if needed */
+	mutex_lock(&input->mutex);
+	if (input->users)
+		err = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return err;
+}
+
+static void dwav_usb_mt_free_buffers(struct usb_device *udev,
+				  struct dwav_usb_mt *dwav_usb_mt)
+{
+	usb_free_coherent(udev, dwav_usb_mt->data_size,
+			dwav_usb_mt->data, dwav_usb_mt->data_dma);
+}
+
+static struct usb_endpoint_descriptor *dwav_usb_mt_get_input_endpoint(
+		struct usb_host_interface *interface)
+{
+	int i;
+
+	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
+		if (usb_endpoint_dir_in(&interface->endpoint[i].desc))
+			return &interface->endpoint[i].desc;
+	}
+
+	return NULL;
+}
+
+static int dwav_usb_mt_init(struct dwav_usb_mt *dwav_usb_mt, void *dev)
+{
+	int err;
+	struct input_dev *input_dev = (struct input_dev *)dev;
+
+	input_dev->name = dwav_usb_mt->name;
+	input_dev->phys = dwav_usb_mt->phys;
+
+	input_set_drvdata(input_dev, dwav_usb_mt);
+
+	input_dev->open = dwav_usb_mt_open;
+	input_dev->close = dwav_usb_mt_close;
+
+	input_dev->id.bustype = BUS_USB;
+
+	/* single touch */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+
+	/* multi touch */
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+	input_mt_init_slots(input_dev,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_finger, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		pr_err("%s - input_register_device failed, err: %d\n",
+				__func__, err);
+		return  err;
+	}
+
+	dwav_usb_mt->input = input_dev;
+
+	return  0;
+}
+
+static int dwav_usb_mt_probe(struct usb_interface *intf,
+			  const struct usb_device_id *id)
+{
+	struct dwav_usb_mt *dwav_usb_mt = NULL;
+	struct input_dev *input_dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int err = 0;
+
+	endpoint = dwav_usb_mt_get_input_endpoint(intf->cur_altsetting);
+	if (!endpoint)
+		return  -ENXIO;
+
+	dwav_usb_mt = kzalloc(sizeof(struct dwav_usb_mt), GFP_KERNEL);
+	if (!dwav_usb_mt)
+		return  -ENOMEM;
+
+	dwav_usb_mt->dev_id = id->driver_info;
+
+	dwav_usb_mt->finger = kzalloc(sizeof(struct finger_t) *
+				      DEV_INFO[dwav_usb_mt->dev_id].max_finger,
+				      GFP_KERNEL);
+
+	if (!dwav_usb_mt->finger)
+		goto err_free_mem;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err_free_mem;
+
+	dwav_usb_mt->data_size = sizeof(struct dwav_raw);
+	dwav_usb_mt->data = usb_alloc_coherent(udev, dwav_usb_mt->data_size,
+			GFP_KERNEL, &dwav_usb_mt->data_dma);
+	if (!dwav_usb_mt->data)
+		goto err_free_mem;
+
+	dwav_usb_mt->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dwav_usb_mt->irq) {
+		dev_dbg(&intf->dev,
+				"%s - usb_alloc_urb failed: usbtouch->irq\n",
+				__func__);
+		goto err_free_buffers;
+	}
+
+	if (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)   {
+		usb_fill_int_urb(dwav_usb_mt->irq, udev,
+			usb_rcvintpipe(udev, endpoint->bEndpointAddress),
+			dwav_usb_mt->data, dwav_usb_mt->data_size,
+			dwav_usb_mt_irq, dwav_usb_mt, endpoint->bInterval);
+	} else {
+		usb_fill_bulk_urb(dwav_usb_mt->irq, udev,
+			 usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),
+			 dwav_usb_mt->data, dwav_usb_mt->data_size,
+			 dwav_usb_mt_irq, dwav_usb_mt);
+	}
+
+	dwav_usb_mt->irq->dev = udev;
+	dwav_usb_mt->irq->transfer_dma = dwav_usb_mt->data_dma;
+	dwav_usb_mt->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	dwav_usb_mt->interface  = intf;
+
+	if (udev->manufacturer)
+		strlcpy(dwav_usb_mt->name,
+				udev->manufacturer, sizeof(dwav_usb_mt->name));
+
+	if (udev->product) {
+		if (udev->manufacturer)
+			strlcat(dwav_usb_mt->name,
+					" ", sizeof(dwav_usb_mt->name));
+
+		strlcat(dwav_usb_mt->name,
+				udev->product, sizeof(dwav_usb_mt->name));
+	}
+
+	if (!strlen(dwav_usb_mt->name)) {
+		snprintf(dwav_usb_mt->name, sizeof(dwav_usb_mt->name),
+				"D-WAV Scientific MultiTouch %04x:%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	usb_make_path(udev, dwav_usb_mt->phys, sizeof(dwav_usb_mt->phys));
+	strlcat(dwav_usb_mt->phys, "/input0", sizeof(dwav_usb_mt->phys));
+
+	usb_to_input_id(udev, &input_dev->id);
+
+	input_dev->dev.parent = &intf->dev;
+
+	err = dwav_usb_mt_init(dwav_usb_mt, (void *)input_dev);
+	if (err)
+		goto err_free_urb;
+
+	usb_set_intfdata(intf, dwav_usb_mt);
+
+	dev_info(&intf->dev, "%s\n", DEV_INFO[dwav_usb_mt->dev_id].name);
+
+	return 0;
+
+err_free_urb:
+	usb_free_urb(dwav_usb_mt->irq);
+
+err_free_buffers:
+	dwav_usb_mt_free_buffers(udev, dwav_usb_mt);
+
+err_free_mem:
+	if (input_dev)
+		input_free_device(input_dev);
+	kfree(dwav_usb_mt);
+
+	return err;
+}
+
+static void dwav_usb_mt_disconnect(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	if (!dwav_usb_mt)
+		return;
+
+	dev_dbg(&intf->dev,
+			"%s - dwav_usb_mt is initialized, cleaning up\n",
+			__func__);
+
+	usb_set_intfdata(intf, NULL);
+
+	/* this will stop IO via close */
+	input_unregister_device(dwav_usb_mt->input);
+
+	usb_free_urb(dwav_usb_mt->irq);
+
+	dwav_usb_mt_free_buffers(interface_to_usbdev(intf), dwav_usb_mt);
+
+	kfree(dwav_usb_mt);
+}
+
+MODULE_DEVICE_TABLE(usb, dwav_usb_mt_devices);
+
+static struct usb_driver dwav_usb_mt_driver = {
+	.name = "dwav_usb_mt",
+	.probe = dwav_usb_mt_probe,
+	.disconnect = dwav_usb_mt_disconnect,
+	.suspend = dwav_usb_mt_suspend,
+	.resume = dwav_usb_mt_resume,
+	.reset_resume = dwav_usb_mt_reset_resume,
+	.id_table = dwav_usb_mt_devices,
+	.supports_autosuspend = 1,
+};
+
+module_usb_driver(dwav_usb_mt_driver);
+
+MODULE_AUTHOR("Hardkernel Co.,Ltd");
+MODULE_DESCRIPTION("D-WAV USB(HID) MultiTouch Driver");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS("dwav_usb_mt");
\ No newline at end of file
diff -Naur a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
--- a/drivers/input/touchscreen/Kconfig	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/input/touchscreen/Kconfig	2021-10-19 00:24:08.000000000 -0400
@@ -1366,4 +1366,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_DWAV_USB_MT
+	tristate "D-WAV Scientific USB MultiTouch"
+	depends on USB_ARCH_HAS_HCD
+	select USB
+	help
+	  Say Y here if you have a D-WAV Scientific USB(HID) based MultiTouch
+	  controller.
+
+	  module will be called dwav-usb-mt.
+
 endif
diff -Naur a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
--- a/drivers/input/touchscreen/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/input/touchscreen/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -114,3 +114,4 @@
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_DWAV_USB_MT)	+= dwav-usb-mt.o
diff -Naur a/drivers/media/platform/s5p-jpeg/jpeg-core.c b/drivers/media/platform/s5p-jpeg/jpeg-core.c
--- a/drivers/media/platform/s5p-jpeg/jpeg-core.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/media/platform/s5p-jpeg/jpeg-core.c	2021-10-19 00:24:08.000000000 -0400
@@ -1785,6 +1785,31 @@
  * V4L2 controls
  */
 
+static int vidioc_decoder_cmd(struct file *file, void *priv,
+			struct v4l2_decoder_cmd *cmd)
+{
+	struct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);
+	struct vb2_queue *vq_src = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	struct vb2_v4l2_buffer *buf;
+
+	switch (cmd->cmd) {
+	case V4L2_DEC_CMD_STOP:
+		if (cmd->flags != 0)
+			return -EINVAL;
+		if (!vb2_is_streaming(vq_src))
+			return -EINVAL;
+
+		buf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);
+		buf->flags |= V4L2_BUF_FLAG_LAST;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int s5p_jpeg_g_selection(struct file *file, void *priv,
 			 struct v4l2_selection *s)
 {
@@ -1819,9 +1844,6 @@
 	return 0;
 }
 
-/*
- * V4L2 controls
- */
 static int s5p_jpeg_s_selection(struct file *file, void *fh,
 				  struct v4l2_selection *s)
 {
@@ -2013,6 +2035,8 @@
 	.vidioc_streamon		= v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff		= v4l2_m2m_ioctl_streamoff,
 
+	.vidioc_decoder_cmd             = vidioc_decoder_cmd,
+
 	.vidioc_g_selection		= s5p_jpeg_g_selection,
 	.vidioc_s_selection		= s5p_jpeg_s_selection,
 
@@ -2459,13 +2483,6 @@
 
 	size = q_data->size;
 
-	/*
-	 * header is parsed during decoding and parsed information stored
-	 * in the context so we do not allow another buffer to overwrite it
-	 */
-	if (ctx->mode == S5P_JPEG_DECODE)
-		count = 1;
-
 	*nbuffers = count;
 	*nplanes = 1;
 	sizes[0] = size;
@@ -2573,6 +2590,7 @@
 static void s5p_jpeg_stop_streaming(struct vb2_queue *q)
 {
 	struct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *buf;
 
 	/*
 	 * STREAMOFF is an acknowledgment for resolution change event.
@@ -2585,6 +2603,11 @@
 		ctx->state = JPEGCTX_RUNNING;
 	}
 
+	while ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+	while ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+
 	pm_runtime_put(ctx->jpeg->dev);
 }
 
@@ -2824,6 +2847,8 @@
 	v4l2_m2m_buf_done(src_buf, state);
 	if (curr_ctx->mode == S5P_JPEG_ENCODE)
 		vb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);
+	if (src_buf->flags & V4L2_BUF_FLAG_LAST)
+		dst_buf->flags |= V4L2_BUF_FLAG_LAST;
 	v4l2_m2m_buf_done(dst_buf, state);
 
 	curr_ctx->subsampling =
diff -Naur a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c	2021-10-19 00:24:08.000000000 -0400
@@ -858,7 +858,7 @@
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -893,7 +893,7 @@
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -941,6 +941,11 @@
 	mfc_debug_enter();
 	if (dev)
 		mutex_lock(&dev->mfc_mutex);
+
+	/* stop streaming */
+	vb2_streamoff(&ctx->vq_src, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	vb2_streamoff(&ctx->vq_dst, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
 	vb2_queue_release(&ctx->vq_src);
 	vb2_queue_release(&ctx->vq_dst);
 	if (dev) {
diff -Naur a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c	2021-10-19 00:24:08.000000000 -0400
@@ -615,8 +615,8 @@
 	struct s5p_mfc_ctx *ctx = fh_to_ctx(priv);
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err("Call on QBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err("Call on QBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 	if (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		return vb2_qbuf(&ctx->vq_src, NULL, buf);
@@ -635,8 +635,8 @@
 	int ret;
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err_limited("Call on DQBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err_limited("Call on DQBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 
 	switch (buf->type) {
diff -Naur a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c	2021-10-19 00:24:08.000000000 -0400
@@ -1214,6 +1214,7 @@
 {
 	struct s5p_mfc_dev *dev = ctx->dev;
 	struct s5p_mfc_buf *mb_entry;
+	struct s5p_mfc_buf *dst_buf;
 	unsigned long enc_y_addr = 0, enc_c_addr = 0;
 	unsigned long mb_y_addr, mb_c_addr;
 	int slice_type;
@@ -1233,8 +1234,12 @@
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->src_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
@@ -1247,8 +1252,12 @@
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->ref_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2021-10-19 00:24:08.000000000 -0400
@@ -743,12 +743,16 @@
 	if (wol->wolopts) {
 		pr_info("stmmac: wakeup enable\n");
 		device_set_wakeup_enable(priv->device, 1);
-		enable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			enable_irq_wake(priv->wol_irq);
 	} else {
 		device_set_wakeup_enable(priv->device, 0);
-		disable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			disable_irq_wake(priv->wol_irq);
 	}
 
+	phylink_ethtool_set_wol(priv->phylink, wol);
+
 	mutex_lock(&priv->lock);
 	priv->wolopts = wol->wolopts;
 	mutex_unlock(&priv->lock);
diff -Naur a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
--- a/drivers/net/phy/realtek.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/net/phy/realtek.c	2021-10-19 00:24:08.000000000 -0400
@@ -12,6 +12,8 @@
 #include <linux/phy.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
 
 #define RTL821x_PHYSR				0x11
 #define RTL821x_PHYSR_DUPLEX			BIT(13)
@@ -300,6 +302,51 @@
 	return IRQ_HANDLED;
 }
 
+static int rtl8211f_set_wol(struct phy_device *phydev,
+		struct ethtool_wolinfo *wol)
+{
+	struct net_device *ndev = phydev->attached_dev;
+	const u8 *mac;
+	int val;
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		mac = (const u8 *)ndev->dev_addr;
+
+		if (!is_valid_ether_addr(mac))
+			return -EINVAL;
+
+		/* Set MAC address */
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0xd8c);
+		phy_write(phydev, 0x10, (mac[1] << 8) | mac[0]);
+		phy_write(phydev, 0x11, (mac[3] << 8) | mac[2]);
+		phy_write(phydev, 0x12, (mac[5] << 8) | mac[4]);
+
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0xd8a);
+
+		/* Set magic packet for WOL */
+		phy_write(phydev, 0x10, 0x1000);
+		phy_write(phydev, 0x11, 0x9fff);
+
+		/* PIN31 - pull high */
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0xd40);
+		val = phy_read(phydev, 0x16);
+		phy_write(phydev, 0x16, val | BIT(5));
+
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0);
+	} else {
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0xd8a);
+
+		/* Reset magic packet for WOL */
+		phy_write(phydev, 0x10, 0x0);
+		val = phy_read(phydev, 0x11);
+		phy_write(phydev, 0x11, val & ~BIT(15));
+
+		phy_write(phydev, RTL821x_PAGE_SELECT, 0);
+	}
+
+	return 0;
+}
+
 static int rtl8211_config_aneg(struct phy_device *phydev)
 {
 	int ret;
@@ -909,6 +956,7 @@
 		.handle_interrupt = rtl821x_handle_interrupt,
 		.suspend	= genphy_suspend,
 		.resume		= genphy_resume,
+		.set_wol	= rtl8211f_set_wol,
 		.read_page	= rtl821x_read_page,
 		.write_page	= rtl821x_write_page,
 	}, {
diff -Naur a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig
--- a/drivers/power/reset/Kconfig	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/power/reset/Kconfig	2021-10-19 00:24:08.000000000 -0400
@@ -9,6 +9,13 @@
 
 if POWER_RESET
 
+config POWER_RESET_ODROID
+	bool "odroid reboot/power-off driver"
+	depends on ARCH_MESON
+	help
+	  This driver supports restart / power off board for amlogic
+	  g12a/g12b/sm1 SoCs
+
 config POWER_RESET_AS3722
 	bool "ams AS3722 power-off driver"
 	depends on MFD_AS3722
diff -Naur a/drivers/power/reset/Makefile b/drivers/power/reset/Makefile
--- a/drivers/power/reset/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/power/reset/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_POWER_RESET_ODROID) += odroid-reboot.o
 obj-$(CONFIG_POWER_RESET_AS3722) += as3722-poweroff.o
 obj-$(CONFIG_POWER_RESET_AT91_POWEROFF) += at91-poweroff.o
 obj-$(CONFIG_POWER_RESET_AT91_RESET) += at91-reset.o
diff -Naur a/drivers/power/reset/odroid-reboot.c b/drivers/power/reset/odroid-reboot.c
--- a/drivers/power/reset/odroid-reboot.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/power/reset/odroid-reboot.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,181 @@
+/*
+ * drivers/power/reset/odroid-reboot.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+
+#include <asm/system_misc.h>
+
+#include <asm/compiler.h>
+#include <linux/kdebug.h>
+#include <linux/arm-smccc.h>
+
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+int sd_vqsw;
+int sd_vmmc;
+int sd_vqen;
+
+static u32 psci_function_id_restart;
+static u32 psci_function_id_poweroff;
+
+#define CHECK_RET(ret) { \
+	if (ret) \
+	pr_err("[%s] gpio op failed(%d) at line %d\n",\
+			__func__, ret, __LINE__); \
+}
+
+static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+					 u64 arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id,
+			(unsigned long)arg0,
+			(unsigned long)arg1,
+			(unsigned long)arg2,
+			0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+void odroid_card_reset(void)
+{
+	int ret = 0;
+
+	if ((sd_vqsw == 0) && (sd_vmmc == 0))
+		return;
+
+	if (sd_vqen == 0) {
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vmmc);
+		ret = gpio_request_one(sd_vqsw,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(10);
+		ret = gpio_direction_output(sd_vqsw, 1);
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vmmc,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(10);
+		ret = gpio_direction_output(sd_vqsw, 0);
+		CHECK_RET(ret);
+		ret = gpio_direction_output(sd_vmmc, 1);
+		CHECK_RET(ret);
+		mdelay(5);
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vmmc);
+	} else {
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vqen);
+		gpio_free(sd_vmmc);
+
+		ret = gpio_request_one(sd_vqsw,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vqen,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vmmc,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(100);
+		ret = gpio_direction_input(sd_vqen);
+		CHECK_RET(ret);
+		ret = gpio_direction_input(sd_vmmc);
+		CHECK_RET(ret);
+		ret = gpio_direction_input(sd_vqsw);
+		CHECK_RET(ret);
+		mdelay(5);
+		gpio_free(sd_vqen);
+		gpio_free(sd_vmmc);
+		gpio_free(sd_vqsw);
+	}
+}
+
+static void do_odroid_restart(enum reboot_mode reboot_mode, const char *cmd)
+{
+	odroid_card_reset();
+	__invoke_psci_fn_smc(psci_function_id_restart,
+				0, 0, 0);
+}
+
+static void do_odroid_poweroff(void)
+{
+	odroid_card_reset();
+
+	__invoke_psci_fn_smc(0x82000042, 1, 0, 0);
+	__invoke_psci_fn_smc(psci_function_id_poweroff,
+				0, 0, 0);
+}
+
+static int odroid_restart_probe(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	u32 id;
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_reset", &id)) {
+		psci_function_id_restart = id;
+		arm_pm_restart = do_odroid_restart;
+	}
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_poweroff", &id)) {
+		psci_function_id_poweroff = id;
+		pm_power_off = do_odroid_poweroff;
+	}
+
+	of_node = pdev->dev.of_node;
+
+	sd_vqsw = of_get_named_gpio(of_node, "sd-vqsw", 0);
+	if (!gpio_is_valid(sd_vqsw)) sd_vqsw = 0;
+
+	sd_vmmc = of_get_named_gpio(of_node, "sd-vmmc", 0);
+	if (!gpio_is_valid(sd_vmmc)) sd_vmmc = 0;
+
+	sd_vqen = of_get_named_gpio(of_node, "sd-vqen", 0);
+	if (!gpio_is_valid(sd_vqen)) sd_vqen = 0;
+
+	return 0;
+}
+
+static const struct of_device_id of_odroid_restart_match[] = {
+	{ .compatible = "odroid,reboot", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_odroid_restart_match);
+
+static struct platform_driver odroid_restart_driver = {
+	.probe = odroid_restart_probe,
+	.driver = {
+		.name = "odroid-restart",
+		.of_match_table = of_match_ptr(of_odroid_restart_match),
+	},
+};
+
+static int __init odroid_restart_init(void)
+{
+	return platform_driver_register(&odroid_restart_driver);
+}
+device_initcall(odroid_restart_init);
diff -Naur a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
--- a/drivers/pwm/Kconfig	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/pwm/Kconfig	2021-10-19 00:24:08.000000000 -0400
@@ -195,6 +195,21 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-fsl-ftm.
 
+config PWM_GPIO
+	tristate "Generic GPIO bit-banged PWM driver"
+	depends on OF
+	depends on GPIOLIB
+	help
+	  Some platforms do not offer any hardware PWM capabilities but do have
+	  General Purpose Input Output (GPIO) pins available. Using the kernels
+	  High-Resolution Timer API this driver tries to toggle GPIO using the
+	  generic kernel PWM framework. The maximum frequency and/or accuracy
+	  is dependent on several factors such as system load and the maximum
+	  speed a pin can be toggled at the hardware.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-gpio.
+
 config PWM_HIBVT
 	tristate "HiSilicon BVT PWM support"
 	depends on ARCH_HISI || COMPILE_TEST
diff -Naur a/drivers/pwm/Makefile b/drivers/pwm/Makefile
--- a/drivers/pwm/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/pwm/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -16,6 +16,7 @@
 obj-$(CONFIG_PWM_DWC)		+= pwm-dwc.o
 obj-$(CONFIG_PWM_EP93XX)	+= pwm-ep93xx.o
 obj-$(CONFIG_PWM_FSL_FTM)	+= pwm-fsl-ftm.o
+obj-$(CONFIG_PWM_GPIO)		+= pwm-gpio.o
 obj-$(CONFIG_PWM_HIBVT)		+= pwm-hibvt.o
 obj-$(CONFIG_PWM_IMG)		+= pwm-img.o
 obj-$(CONFIG_PWM_IMX1)		+= pwm-imx1.o
diff -Naur a/drivers/pwm/pwm-gpio.c b/drivers/pwm/pwm-gpio.c
--- a/drivers/pwm/pwm-gpio.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/pwm/pwm-gpio.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2015 Olliver Schinagl <oliver@schinagl.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This driver adds a high-resolution timer based PWM driver. Since this is a
+ * bit-banged driver, accuracy will always depend on a lot of factors, such as
+ * GPIO toggle speed and system load.
+ */
+
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/property.h>
+#include <linux/pwm.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#define DRV_NAME "pwm-gpio"
+
+struct gpio_pwm_data {
+	struct hrtimer timer;
+	struct gpio_desc *gpiod;
+	bool polarity;
+	bool pin_on;
+	int on_time;
+	int off_time;
+	bool run;
+};
+
+struct gpio_pwm_chip {
+	struct pwm_chip chip;
+};
+
+static void gpio_pwm_off(struct gpio_pwm_data *gpio_data)
+{
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 0 : 1);
+}
+
+static void gpio_pwm_on(struct gpio_pwm_data *gpio_data)
+{
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 1 : 0);
+}
+
+enum hrtimer_restart gpio_pwm_timer(struct hrtimer *timer)
+{
+	struct gpio_pwm_data *gpio_data = container_of(timer,
+						      struct gpio_pwm_data,
+						      timer);
+	if (!gpio_data->run) {
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
+		return HRTIMER_NORESTART;
+	}
+
+	if (!gpio_data->pin_on) {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->on_time));
+		gpio_pwm_on(gpio_data);
+		gpio_data->pin_on = true;
+	} else {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->off_time));
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
+	}
+
+	return HRTIMER_RESTART;
+}
+
+static int gpio_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			    int duty_ns, int period_ns)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->on_time = duty_ns;
+	gpio_data->off_time = period_ns - duty_ns;
+
+	return 0;
+}
+
+static int gpio_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				 enum pwm_polarity polarity)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->polarity = (polarity != PWM_POLARITY_NORMAL) ? true : false;
+
+	return 0;
+}
+
+static int gpio_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	if (gpio_data->run)
+		return -EBUSY;
+
+	gpio_data->run = true;
+	if (gpio_data->off_time) {
+		hrtimer_start(&gpio_data->timer, ktime_set(0, 0),
+			      HRTIMER_MODE_REL);
+	} else {
+		if (gpio_data->on_time)
+			gpio_pwm_on(gpio_data);
+		else
+			gpio_pwm_off(gpio_data);
+	}
+
+	return 0;
+}
+
+static void gpio_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->run = false;
+	if (!gpio_data->off_time)
+		gpio_pwm_off(gpio_data);
+}
+
+static const struct pwm_ops gpio_pwm_ops = {
+	.config = gpio_pwm_config,
+	.set_polarity = gpio_pwm_set_polarity,
+	.enable = gpio_pwm_enable,
+	.disable = gpio_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int gpio_pwm_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct gpio_pwm_chip *gpio_chip;
+	int npwm, i;
+	int hrtimer = 0;
+
+	npwm = of_gpio_named_count(pdev->dev.of_node, "pwm-gpios");
+	if (npwm < 1)
+		return -ENODEV;
+
+	gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*gpio_chip), GFP_KERNEL);
+	if (!gpio_chip)
+		return -ENOMEM;
+
+	gpio_chip->chip.dev = &pdev->dev;
+	gpio_chip->chip.ops = &gpio_pwm_ops;
+	gpio_chip->chip.base = -1;
+	gpio_chip->chip.npwm = npwm;
+	gpio_chip->chip.of_xlate = of_pwm_xlate_with_flags;
+	gpio_chip->chip.of_pwm_n_cells = 3;
+
+	ret = pwmchip_add(&gpio_chip->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < npwm; i++) {
+		struct gpio_desc *gpiod;
+		struct gpio_pwm_data *gpio_data;
+
+		gpiod = devm_gpiod_get_index(&pdev->dev, "pwm", i,
+					     GPIOD_OUT_LOW);
+		if (IS_ERR(gpiod)) {
+			int error;
+
+			error = PTR_ERR(gpiod);
+			if (error != -EPROBE_DEFER)
+				dev_err(&pdev->dev,
+					"failed to get gpio flags, error: %d\n",
+					error);
+			return error;
+		}
+
+		gpio_data = devm_kzalloc(&pdev->dev, sizeof(*gpio_data),
+					 GFP_KERNEL);
+
+		hrtimer_init(&gpio_data->timer,
+			     CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		gpio_data->timer.function = &gpio_pwm_timer;
+		gpio_data->gpiod = gpiod;
+		gpio_data->pin_on = false;
+		gpio_data->run = false;
+
+		if (hrtimer_is_hres_active(&gpio_data->timer))
+			hrtimer++;
+
+		pwm_set_chip_data(&gpio_chip->chip.pwms[i], gpio_data);
+	}
+	if (!hrtimer) {
+		dev_warn(&pdev->dev, "unable to use High-Resolution timer,");
+		dev_warn(&pdev->dev, "%s is restricted to low resolution.",
+			 DRV_NAME);
+	}
+
+	platform_set_drvdata(pdev, gpio_chip);
+
+	dev_info(&pdev->dev, "%d gpio pwms loaded\n", npwm);
+
+	return 0;
+}
+
+static int gpio_pwm_remove(struct platform_device *pdev)
+{
+	struct gpio_pwm_chip *gpio_chip;
+	int i;
+
+	gpio_chip = platform_get_drvdata(pdev);
+	for (i = 0; i < gpio_chip->chip.npwm; i++) {
+		struct gpio_pwm_data *gpio_data;
+
+		gpio_data = pwm_get_chip_data(&gpio_chip->chip.pwms[i]);
+
+		hrtimer_cancel(&gpio_data->timer);
+	}
+
+	return pwmchip_remove(&gpio_chip->chip);
+}
+
+static const struct of_device_id gpio_pwm_of_match[] = {
+	{ .compatible = DRV_NAME, },
+	{/* sentinel */},
+};
+MODULE_DEVICE_TABLE(of, gpio_pwm_of_match);
+
+static struct platform_driver gpio_pwm_driver = {
+	.probe = gpio_pwm_probe,
+	.remove = gpio_pwm_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(gpio_pwm_of_match),
+	},
+};
+module_platform_driver(gpio_pwm_driver);
+
+MODULE_AUTHOR("Olliver Schinagl <oliver@schinagl.nl>");
+MODULE_DESCRIPTION("Generic GPIO bit-banged PWM driver");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c
--- a/drivers/regulator/s2mps11.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/regulator/s2mps11.c	2021-10-19 00:24:08.000000000 -0400
@@ -1117,6 +1117,57 @@
 	regulator_desc_s2mpu02_buck7(7),
 };
 
+static int s2mps11_pmic_ethonoff(struct platform_device *pdev, bool onoff)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L15CTRL value\n");
+		return ret;
+	}
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L17CTRL value\n");
+		return ret;
+	}
+
+	if (onoff) {
+		/* ETH VDD0 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	} else {
+		/* ETH VDD0 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
 static int s2mps11_pmic_probe(struct platform_device *pdev)
 {
 	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
@@ -1225,6 +1276,34 @@
 	return ret;
 }
 
+static void s2mps11_pmic_shutdown(struct platform_device *pdev)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val, ret;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_CTRL1, &reg_val);
+	if (ret < 0) {
+		dev_crit(&pdev->dev, "could not read S2MPS11_REG_CTRL1 value\n");
+	} else {
+		/*
+		 * s2mps11-pmic: S2MPS11_REG_CTRL1 reg value
+		 * is 00000000000000000000000000010000
+		 * clear the S2MPS11_REG_CTRL1 0x10 value to shutdown.
+		 */
+		if (reg_val & BIT(4)) {
+			ret = regmap_update_bits(iodev->regmap_pmic,
+						 S2MPS11_REG_CTRL1,
+						 BIT(4), BIT(0));
+			if (ret)
+				dev_crit(&pdev->dev,
+					 "could not write S2MPS11_REG_CTRL1 value\n");
+		}
+	}
+	s2mps11_pmic_ethonoff(pdev, false);
+	mdelay(10);
+	s2mps11_pmic_ethonoff(pdev, true);
+}
+
 static const struct platform_device_id s2mps11_pmic_id[] = {
 	{ "s2mps11-regulator", S2MPS11X},
 	{ "s2mps13-regulator", S2MPS13X},
@@ -1240,6 +1319,7 @@
 		.name = "s2mps11-pmic",
 	},
 	.probe = s2mps11_pmic_probe,
+	.shutdown = s2mps11_pmic_shutdown,
 	.id_table = s2mps11_pmic_id,
 };
 
diff -Naur a/drivers/spi/spidev.c b/drivers/spi/spidev.c
--- a/drivers/spi/spidev.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/spi/spidev.c	2021-10-19 00:24:08.000000000 -0400
@@ -696,6 +696,8 @@
 	{ .compatible = "menlo,m53cpld" },
 	{ .compatible = "cisco,spi-petra" },
 	{ .compatible = "micron,spi-authenta" },
+	/* ODROID Modification */
+	{ .compatible = "odroid,spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -Naur a/drivers/staging/fbtft/fb_hktft32.c b/drivers/staging/fbtft/fb_hktft32.c
--- a/drivers/staging/fbtft/fb_hktft32.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/staging/fbtft/fb_hktft32.c	2021-10-19 00:24:08.000000000 -0400
@@ -0,0 +1,156 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * FB driver for the Hardkernel 3.2 inch TFT LCD
+ * that uses the ILI9340 LCD Controller
+ *
+ * Copyright (C) 2019 Yang Deokgyu
+ *
+ * Based on fb_ili9340.c by Noralf Tronnes
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <video/mipi_display.h>
+
+#include "fbtft.h"
+
+#define DRVNAME		"fb_hktft32"
+#define WIDTH		240
+#define HEIGHT		320
+
+/* Init sequence taken from: Arduino Library for the Adafruit 2.2" display */
+static int init_display(struct fbtft_par *par)
+{
+	par->fbtftops.reset(par);
+
+	write_reg(par, 0xEF, 0x03, 0x80, 0x02);
+	write_reg(par, 0xCF, 0x00, 0XC1, 0X30);
+	write_reg(par, 0xED, 0x64, 0x03, 0X12, 0X81);
+	write_reg(par, 0xE8, 0x85, 0x00, 0x78);
+	write_reg(par, 0xCB, 0x39, 0x2C, 0x00, 0x34, 0x02);
+	write_reg(par, 0xF7, 0x20);
+	write_reg(par, 0xEA, 0x00, 0x00);
+
+	/* Power Control 1 */
+	write_reg(par, 0xC0, 0x23);
+
+	/* Power Control 2 */
+	write_reg(par, 0xC1, 0x10);
+
+	/* VCOM Control 1 */
+	write_reg(par, 0xC5, 0x3e, 0x28);
+
+	/* VCOM Control 2 */
+	write_reg(par, 0xC7, 0x86);
+
+	/* COLMOD: Pixel Format Set */
+	/* 16 bits/pixel */
+	write_reg(par, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+
+	/* Frame Rate Control */
+	/* Division ratio = fosc, Frame Rate = 79Hz */
+	write_reg(par, 0xB1, 0x00, 0x18);
+
+	/* Display Function Control */
+	write_reg(par, 0xB6, 0x08, 0x82, 0x27);
+
+	/* Gamma Function Disable */
+	write_reg(par, 0xF2, 0x00);
+
+	/* Gamma curve selection */
+	write_reg(par, MIPI_DCS_SET_GAMMA_CURVE, 0x01);
+
+	/* Positive Gamma Correction */
+	write_reg(par, 0xE0,
+		  0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, 0x4E, 0xF1,
+		  0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00);
+
+	/* Negative Gamma Correction */
+	write_reg(par, 0xE1,
+		  0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, 0x31, 0xC1,
+		  0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F);
+
+	write_reg(par, MIPI_DCS_EXIT_SLEEP_MODE);
+
+	mdelay(120);
+
+	write_reg(par, MIPI_DCS_SET_DISPLAY_ON);
+
+	return 0;
+}
+
+static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
+{
+	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
+		  xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
+
+	write_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,
+		  ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
+
+	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
+}
+
+#define ILI9340_MADCTL_MV  0x20
+#define ILI9340_MADCTL_MX  0x40
+#define ILI9340_MADCTL_MY  0x80
+static int set_var(struct fbtft_par *par)
+{
+	u8 val;
+
+	switch (par->info->var.rotate) {
+	case 270:
+		val = ILI9340_MADCTL_MV;
+		break;
+	case 180:
+		val = ILI9340_MADCTL_MY;
+		break;
+	case 90:
+		val = ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX;
+		break;
+	default:
+		val = ILI9340_MADCTL_MX;
+		break;
+	}
+	/* Memory Access Control  */
+	write_reg(par, MIPI_DCS_SET_ADDRESS_MODE, val | (par->bgr << 3));
+
+	return 0;
+}
+
+static void reset(struct fbtft_par *par)
+{
+	if (!par->gpio.reset)
+		return;
+	fbtft_par_dbg(DEBUG_RESET, par, "%s()\n", __func__);
+	gpiod_set_value_cansleep(par->gpio.reset, 0);
+	usleep_range(20, 40);
+	gpiod_set_value_cansleep(par->gpio.reset, 1);
+	msleep(120);
+}
+
+static struct fbtft_display display = {
+	.regwidth = 8,
+	.buswidth = 8,
+	.width = WIDTH,
+	.height = HEIGHT,
+	.fbtftops = {
+		.init_display = init_display,
+		.set_addr_win = set_addr_win,
+		.set_var = set_var,
+		.reset = reset,
+	},
+};
+
+FBTFT_REGISTER_DRIVER(DRVNAME, "odroid,hktft32", &display);
+
+MODULE_ALIAS("spi:" DRVNAME);
+MODULE_ALIAS("platform:" DRVNAME);
+MODULE_ALIAS("spi:hktft32");
+MODULE_ALIAS("platform:hktft32");
+
+MODULE_DESCRIPTION("FB driver for the Hardkernel 3.2 inch TFT LCD uses the ILI9340 LCD Controller");
+MODULE_AUTHOR("Yang Deokgyu");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/staging/fbtft/Kconfig b/drivers/staging/fbtft/Kconfig
--- a/drivers/staging/fbtft/Kconfig	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/staging/fbtft/Kconfig	2021-10-19 00:24:08.000000000 -0400
@@ -206,3 +206,17 @@
 	depends on FB_TFT
 	help
 	  Generic Framebuffer support for WATTEROTT
+
+config FB_TFT_HKTFT35
+	tristate "FB driver for the Hardkernel 3.5 inch TFT LCD"
+	depends on FB_TFT
+	help
+	  Generic Framebuffer support for the Hardkernel 3.5 inch TFT LCD
+	  that uses the ILI9488 LCD Controller
+
+config FB_TFT_HKTFT32
+	tristate "FB driver for the Hardkernel 3.2 inch TFT LCD"
+	depends on FB_TFT
+	help
+	  Generic Framebuffer support for the Hardkernel 3.2 inch TFT LCD
+	  that uses the ILI9340 LCD Controller
diff -Naur a/drivers/staging/fbtft/Makefile b/drivers/staging/fbtft/Makefile
--- a/drivers/staging/fbtft/Makefile	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/staging/fbtft/Makefile	2021-10-19 00:24:08.000000000 -0400
@@ -37,3 +37,5 @@
 obj-$(CONFIG_FB_TFT_UC1701)      += fb_uc1701.o
 obj-$(CONFIG_FB_TFT_UPD161704)   += fb_upd161704.o
 obj-$(CONFIG_FB_TFT_WATTEROTT)   += fb_watterott.o
+obj-$(CONFIG_FB_TFT_HKTFT35)     += fb_hktft35.o
+obj-$(CONFIG_FB_TFT_HKTFT32)     += fb_hktft32.o
diff -Naur a/drivers/thermal/thermal_helpers.c b/drivers/thermal/thermal_helpers.c
--- a/drivers/thermal/thermal_helpers.c	2021-10-18 02:00:13.000000000 -0400
+++ b/drivers/thermal/thermal_helpers.c	2021-10-19 00:24:08.000000000 -0400
@@ -75,6 +75,10 @@
  *
  * Return: On success returns 0, an error code otherwise
  */
+
+#define	CRITICAL_TEMP	120000
+int thermal_zone_data[4] = { 0, };
+
 int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)
 {
 	int ret = -EINVAL;
@@ -108,6 +112,30 @@
 			*temp = tz->emul_temperature;
 	}
 
+	/* save thermal_zone data */
+	if (!ret)
+		thermal_zone_data[tz->id] = *temp;
+	/*
+	 * This case is that the thermal sensor is broken.
+	 * That's not real temperature. Set the fake temperature value in order to
+	 * avoid reaching the ciritical temperature.
+	 */
+	if ((thermal_zone_data[tz->id] > CRITICAL_TEMP) && (tz->id != 4)) {
+		int i, broken_sensor = 0, correct_temp = 0;
+		for (i = 0; i < 4; i++) {
+			if ((thermal_zone_data[i] <= CRITICAL_TEMP) &&
+			    (correct_temp <= thermal_zone_data[i]))
+				correct_temp = thermal_zone_data[i];
+			if (thermal_zone_data[i] > CRITICAL_TEMP)
+				broken_sensor++;
+		}
+		/*
+		 * if all thermal sensor broken then critical temperature data send
+		 * for system poweroff.
+		 */
+		*temp = (broken_sensor == 4) ? CRITICAL_TEMP : correct_temp;
+	}
+
 	mutex_unlock(&tz->lock);
 exit:
 	return ret;
diff -Naur a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	2021-10-18 02:00:13.000000000 -0400
+++ b/MAINTAINERS	2021-10-19 00:24:08.000000000 -0400
@@ -7813,6 +7813,11 @@
 F:	drivers/i2c/muxes/i2c-mux-gpio.c
 F:	include/linux/platform_data/i2c-mux-gpio.h
 
+GENERIC GPIO PWM DRIVER
+M:	Olliver Schinagl <oliver@schinagl.nl>
+S:	Maintained
+F:	drivers/pwm/pwm-gpio.c
+
 GENERIC HDLC (WAN) DRIVERS
 M:	Krzysztof Halasa <khc@pm.waw.pl>
 S:	Maintained
diff -Naur a/sound/soc/meson/axg-frddr.c b/sound/soc/meson/axg-frddr.c
--- a/sound/soc/meson/axg-frddr.c	2021-10-18 02:00:13.000000000 -0400
+++ b/sound/soc/meson/axg-frddr.c	2021-10-19 00:24:08.000000000 -0400
@@ -106,7 +106,7 @@
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
@@ -180,7 +180,7 @@
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
diff -Naur a/sound/soc/meson/Kconfig b/sound/soc/meson/Kconfig
--- a/sound/soc/meson/Kconfig	2021-12-02 05:44:15.661126718 -0500
+++ b/sound/soc/meson/Kconfig	2021-12-02 06:50:53.286052255 -0500
@@ -70,6 +70,8 @@
 	imply SND_MESON_AXG_PDM
 	imply SND_MESON_G12A_TOACODEC
 	imply SND_MESON_G12A_TOHDMITX if DRM_MESON_DW_HDMI
+	imply SND_SOC_MESON_T9015
+	imply SND_SOC_SIMPLE_AMPLIFIER
 	help
 	  Select Y or M to add support for the AXG SoC sound card
 

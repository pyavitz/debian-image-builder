diff -Naur a/arch/arm64/include/asm/system_misc.h b/arch/arm64/include/asm/system_misc.h
--- a/arch/arm64/include/asm/system_misc.h	2023-04-30 19:26:28.000000000 -0400
+++ b/arch/arm64/include/asm/system_misc.h	2023-05-04 11:23:56.988503362 -0400
@@ -32,6 +32,8 @@
 struct mm_struct;
 extern void __show_regs(struct pt_regs *);
 
+extern void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
+
 #endif	/* __ASSEMBLY__ */
 
 #endif	/* __ASM_SYSTEM_MISC_H */
diff -Naur a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c
--- a/arch/arm64/kernel/process.c	2023-04-30 19:26:28.000000000 -0400
+++ b/arch/arm64/kernel/process.c	2023-05-04 11:23:57.006503088 -0400
@@ -68,6 +68,8 @@
 void (*pm_power_off)(void);
 EXPORT_SYMBOL_GPL(pm_power_off);
 
+void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
+
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
 {
@@ -137,7 +139,10 @@
 		efi_reboot(reboot_mode, NULL);
 
 	/* Now call the architecture specific reboot code. */
-	do_kernel_restart(cmd);
+	if (arm_pm_restart)
+		arm_pm_restart(reboot_mode, cmd);
+	else
+		do_kernel_restart(cmd);
 
 	/*
 	 * Whoops - the architecture was unable to reboot.
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/Documentation/devicetree/bindings/pwm/pwm-gpio.txt	2023-05-04 11:23:56.897504751 -0400
@@ -0,0 +1,18 @@
+Generic GPIO bit-banged PWM driver
+
+Required properties:
+  - compatible: should be "pwm-gpio"
+  - #pwm-cells: should be 3, see pwm.txt in this directory for a general
+    description of the cells format.
+  - pwm-gpios: one or more gpios describing the used gpio, see the gpio
+    bindings for the used gpio driver.
+
+Example:
+#include <dt-bindings/gpio/gpio.h>
+
+	pwm: pwm@0 {
+		compatible = "pwm-gpio";
+		#pwm-cells = 3;
+		pwm-gpios = <&pio 7 1 GPIO_ACTIVE_LOW>;
+		pwm-gpios = <&pio 7 2 GPIO_ACTIVE_LOW>;
+	};
diff -Naur a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
--- a/drivers/gpu/drm/meson/meson_vclk.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_vclk.c	2023-05-04 11:23:57.006503088 -0400
@@ -357,6 +357,8 @@
 	MESON_VCLK_HDMI_594000,
 /* 2970 /1 /1 /1 /5 /1  => /1 /2 */
 	MESON_VCLK_HDMI_594000_YUV420,
+/* 4830 /2 /1 /2 /5 /1  => /1 /1 */
+	MESON_VCLK_HDMI_241500,
 };
 
 struct meson_vclk_params {
@@ -467,6 +469,18 @@
 		.vid_pll_div = VID_PLL_DIV_5,
 		.vclk_div = 1,
 	},
+	[MESON_VCLK_HDMI_241500] = {
+		.pll_freq = 4830000,
+		.phy_freq = 2415000,
+		.venc_freq = 241500,
+		.vclk_freq = 241500,
+		.pixel_freq = 241500,
+		.pll_od1 = 2,
+		.pll_od2 = 1,
+		.pll_od3 = 2,
+		.vid_pll_div = VID_PLL_DIV_5,
+		.vclk_div = 1,
+	},
 	{ /* sentinel */ },
 };
 
@@ -873,6 +887,10 @@
 			m = 0xf7;
 			frac = vic_alternate_clock ? 0x8148 : 0x10000;
 			break;
+		case 4830000:
+			m = 0xc9;
+			frac = 0xd560;
+			break;
 		}
 
 		meson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);
diff -Naur a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
--- a/drivers/gpu/drm/meson/meson_venc.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_venc.c	2023-05-04 11:23:57.007503072 -0400
@@ -866,10 +866,11 @@
 			    DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))
 		return MODE_BAD;
 
-	if (mode->hdisplay < 640 || mode->hdisplay > 1920)
+	/* support higher resolution than 1920x1080 */
+	if (mode->hdisplay < 640 || mode->hdisplay > 2560)
 		return MODE_BAD_HVALUE;
 
-	if (mode->vdisplay < 480 || mode->vdisplay > 1200)
+	if (mode->vdisplay < 480 || mode->vdisplay > 1600)
 		return MODE_BAD_VVALUE;
 
 	return MODE_OK;
diff -Naur a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
--- a/drivers/gpu/drm/meson/meson_viu.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/meson/meson_viu.c	2023-05-04 11:23:57.008503057 -0400
@@ -425,6 +425,7 @@
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
 	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
 		meson_viu_load_matrix(priv);
+#if 0
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_viu_set_g12a_osd1_matrix(priv, RGB709_to_YUV709l_coeff,
 					       true);
@@ -433,6 +434,7 @@
 				OSD1_HDR2_CTRL_VDIN0_HDR2_TOP_EN, 0,
 				priv->io_base + _REG(OSD1_HDR2_CTRL));
 	}
+#endif
 
 	/* Initialize OSD1 fifo control register */
 	reg = VIU_OSD_DDR_PRIORITY_URGENT |
diff -Naur a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
--- a/drivers/gpu/drm/tiny/ili9341.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/tiny/ili9341.c	2023-05-04 11:23:57.008503057 -0400
@@ -163,12 +163,14 @@
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/gpu/drm/tiny/ili9488_pio.c	2023-05-04 11:23:57.024502813 -0400
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Hardkernel 3.5 ISP TFT display
+ *
+ * Copyright 2021 Dongjin Kim <tobetter@gmail.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+
+#define ILI9488_COLUMN_ADDR	0x2a
+#define ILI9488_PAGE_ADDR	0x2b
+#define ILI9488_MEMORY_WRITE	0x2c
+#define ILI9488_ITFCTR1         0xb0
+#define ILI9488_FRMCTR1		0xb1
+#define ILI9488_PWCTRL1         0xc2
+#define ILI9488_VMCTRL1         0xc5
+#define ILI9488_PGAMCTRL        0xe0
+#define ILI9488_NGAMCTRL        0xe1
+#define ILI9488_MADCTL_BGR      BIT(3)
+#define ILI9488_MADCTL_MV       BIT(5)
+#define ILI9488_MADCTL_MX       BIT(6)
+#define ILI9488_MADCTL_MY       BIT(7)
+
+struct ili9488_data {
+	struct mipi_dbi_dev *dbidev;
+	struct gpio_desc *wr;
+	struct gpio_desc *cs;
+	struct gpio_desc *db[8];
+	void __iomem *membase;
+	u32 mask;
+	u32 bits[8];
+	u32 bits_wr;
+};
+
+static struct ili9488_data *pdata;
+static u32 *rgb;
+
+static u32 ili9488_rgb565_to_gpiobus(struct ili9488_data *pdata, u8 color)
+{
+	int i;
+	u32 value = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (color & 1)
+			value |= pdata->bits[i];
+		else
+			value &= ~(pdata->bits[i]);
+		color >>= 1;
+	}
+
+	return value;
+}
+
+static int ili9488_bus_write(struct mipi_dbi *dbi, u8 data)
+{
+	int i;
+
+	if (pdata->membase) {
+		u32 v = (readl(pdata->membase) & ~pdata->mask) | *(rgb + data);
+		writel(v, pdata->membase);
+		writel(v | pdata->bits_wr, pdata->membase);
+		return 0;
+	}
+
+	gpiod_set_value(pdata->wr, 0);
+	for (i = 0; i < 8; i++) {
+		gpiod_set_value(pdata->db[i], data & 1);
+		data >>= 1;
+	}
+	gpiod_set_value(pdata->wr, 1);
+
+	return 0;
+}
+
+static int ili9488_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par, size_t num)
+{
+	u8 *p = par;
+
+	gpiod_set_value(dbi->dc, 0);
+	ili9488_bus_write(dbi, *cmd);
+	gpiod_set_value(dbi->dc, 1);
+
+	while (num--)
+		ili9488_bus_write(dbi, *p++);
+
+	return 0;
+}
+
+static void ili9488_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	gpiod_set_value(pdata->cs, 0);
+
+	mipi_dbi_command(dbi, ILI9488_ITFCTR1, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(250);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dbi_command(dbi, ILI9488_PWCTRL1, 0x33);
+	mipi_dbi_command(dbi, ILI9488_VMCTRL1, 0x00, 0x1e, 0x80, 0x00);
+	mipi_dbi_command(dbi, ILI9488_FRMCTR1, 0xb0, 0x11);
+	mipi_dbi_command(dbi, ILI9488_PGAMCTRL,
+			0x00, 0x04, 0x0e, 0x08, 0x17, 0x0a, 0x40, 0x79,
+			0x4d, 0x07, 0x0e, 0x0a, 0x1a, 0x1d, 0x0f);
+	mipi_dbi_command(dbi, ILI9488_NGAMCTRL,
+			0x00, 0x1b, 0x1f, 0x02, 0x10, 0x05, 0x32, 0x34,
+			0x43, 0x02, 0x0a, 0x09, 0x33, 0x37, 0x0f);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+ out_enable:
+	switch (dbidev->rotation) {
+		case 90:
+			addr_mode = ILI9488_MADCTL_MY;
+			break;
+		case 180:
+			addr_mode = ILI9488_MADCTL_MV;
+			break;
+		case 270:
+			addr_mode = ILI9488_MADCTL_MX;
+			break;
+		default:
+			addr_mode = ILI9488_MADCTL_MV | ILI9488_MADCTL_MY |
+				ILI9488_MADCTL_MX;
+			break;
+	}
+
+	addr_mode |= ILI9488_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9488_pipe_funcs = {
+	.enable = ili9488_pipe_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9488_mode = {
+	DRM_SIMPLE_MODE(480, 320, 73, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9488_fops);
+
+static struct drm_driver ili9488_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9488_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.name			= "ili9488",
+	.desc			= "Ilitek ILI9488",
+	.date			= "20210201",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int ili9488_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct mipi_dbi *dbi;
+	struct drm_device *drm;
+	struct mipi_dbi_dev *dbidev;
+	int ret;
+	int i;
+	u32 rotation = 0;
+	struct resource res;
+	char str[32];
+
+	pdata = devm_kzalloc(dev, sizeof(struct ili9488_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	dbidev = devm_drm_dev_alloc(dev, &ili9488_driver,
+			struct mipi_dbi_dev, drm);
+	if (IS_ERR(dbidev))
+		return PTR_ERR(dbidev);
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dbi->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dbi->dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dbi->dc);
+	}
+
+	pdata->wr = devm_gpiod_get(dev, "wr", GPIOD_OUT_HIGH);
+	if (IS_ERR(pdata->wr)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'wr'\n");
+		return PTR_ERR(pdata->wr);
+	}
+
+	pdata->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->cs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'cs'\n");
+		return PTR_ERR(pdata->cs);
+	}
+
+	for (i = 0; i < 8; i++) {
+		struct gpio_desc *desc;
+		int gpio = of_get_named_gpio(np, "db-gpios", i);
+		if (gpio < 0)
+			break;	/* FIXME */
+
+		desc = gpio_to_desc(gpio);
+
+		devm_gpio_request(dev, gpio, NULL);
+		gpiod_direction_output(desc, 1);
+
+		pdata->db[i] = desc;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (!ret) {
+		pdata->membase = devm_ioremap(dev, res.start,
+				resource_size(&res));
+		if (!IS_ERR(pdata->membase)) {
+			for (i = 0; i < 8; i++) {
+				sprintf(str, "db-bits-%d", i);
+				ret = of_property_read_u32(np, str,
+						&pdata->bits[i]);
+				if (ret)
+					continue;
+				pdata->mask |= pdata->bits[i];
+			}
+
+			ret = of_property_read_u32(np, "db-bits-wr",
+					&pdata->bits_wr);
+			if (!ret)
+				pdata->mask |= pdata->bits_wr;
+		}
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	rgb = devm_kzalloc(dev, sizeof(u32) * 256, GFP_KERNEL);
+	if (rgb) {
+		u32 *p = rgb;
+		for (i = 0; i < 256; i++)
+			*p++ = ili9488_rgb565_to_gpiobus(pdata, i);
+	}
+
+	gpiod_set_value(pdata->wr, 1);
+	gpiod_set_value(dbi->dc, 0);
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9488_command;
+	dbi->read_commands = NULL;
+	dbi->swap_bytes = true;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9488_pipe_funcs,
+			&ili9488_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, pdata);
+	pdata->dbidev = dbidev;
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9488_remove(struct platform_device *pdev)
+{
+	struct ili9488_data *pdata = platform_get_drvdata(pdev);
+	struct mipi_dbi_dev *dbidev = pdata->dbidev;
+	struct drm_device *drm = &dbidev->drm;
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static const struct of_device_id ili9488_dt_ids[] = {
+	{ .compatible = "ili9488", 0 },
+	{ .compatible = "hardkernel,ili9488", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, ili9488_dt_ids);
+
+static struct platform_driver ili9488_platform_driver = {
+	.driver = {
+		.name = "ili9488",
+		.of_match_table = ili9488_dt_ids,
+	},
+	.probe = ili9488_probe,
+	.remove = ili9488_remove,
+};
+
+static int __init ili9488_init(void)
+{
+	return platform_driver_register(&ili9488_platform_driver);
+}
+
+static void __exit ili9488_exit(void)
+{
+	platform_driver_unregister(&ili9488_platform_driver);
+}
+
+module_init(ili9488_init);
+module_exit(ili9488_exit);
+
+MODULE_DESCRIPTION("Ilitek ILI9488 DRM driver (8bit PIO mode)");
+MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
--- a/drivers/gpu/drm/tiny/Kconfig	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/tiny/Kconfig	2023-05-04 11:23:57.008503057 -0400
@@ -148,6 +148,19 @@
 
 	  If M is selected the module will be called ili9486.
 
+config TINYDRM_ILI9488_PIO
+	tristate "DRM support for ILI9488 display panels (8bit PIO)"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for th following Ilitek ILI9488 panels:
+          * Hardkernel 3.5" 480x320 TFT (HKTFT 3.5")
+
+	  If M is selected the module will be called hktft35.
+
 config TINYDRM_MI0283QT
 	tristate "DRM support for MI0283QT"
 	depends on DRM && SPI
diff -Naur a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
--- a/drivers/gpu/drm/tiny/Makefile	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/gpu/drm/tiny/Makefile	2023-05-04 11:23:57.008503057 -0400
@@ -11,6 +11,7 @@
 obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
 obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
 obj-$(CONFIG_TINYDRM_ILI9486)		+= ili9486.o
+obj-$(CONFIG_TINYDRM_ILI9488_PIO)	+= ili9488_pio.o
 obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
diff -Naur a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
--- a/drivers/hid/hid-ids.h	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/hid/hid-ids.h	2023-05-04 11:23:57.025502798 -0400
@@ -1423,4 +1423,10 @@
 #define USB_VENDOR_ID_SIGNOTEC			0x2133
 #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
 
+#define USB_DEVICE_ID_DWAV_MULTITOUCH	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define USB_DEVICE_ID_VU5	0x0704
+#define USB_DEVICE_ID_VU7PLUS	0x0705
+
 #endif
diff -Naur a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
--- a/drivers/hid/hid-quirks.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/hid/hid-quirks.c	2023-05-04 11:23:57.026502782 -0400
@@ -879,6 +879,9 @@
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
 #endif
 	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS) },
 	{ }
 };
 
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/input/touchscreen/dwav-usb-mt.c	2023-05-04 11:28:14.122475922 -0400
@@ -0,0 +1,554 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * D-WAV Scientific USB(HID) MultiTouch Screen Driver(Based on usbtouchscreen.c)
+ *
+ * Copyright (C) Hardkernel, 2015
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+
+#include <linux/input/mt.h>
+
+#define USB_VENDOR_ID_DWAV	0x0eef	/* 800 x 480, 7" DWAV touch */
+#define USB_DEVICE_ID_VU7	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define	USB_DEVICE_ID_VU5	0x0704
+#define	USB_DEVICE_ID_VU7PLUS	0x0705
+
+enum	{
+	ODROID_VU7 = 0,	/* 800 x 480, 7" Touch */
+	ODROID_VU5,	/* 800 x 480, 5" Touch */
+	ODROID_VU7PLUS,	/* 1024 x 600, 7" Touch */
+};
+
+struct usbtouch_device_info	{
+	char	name[64];
+	int	max_x;
+	int	max_y;
+	int	max_press;
+	int	max_finger;
+};
+
+const struct usbtouch_device_info DEV_INFO[] = {
+	[ODROID_VU7] = {
+		.name = "ODROID VU7 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU5] = {
+		.name = "ODROID VU5 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU7PLUS] = {
+		.name = "ODROID VU7 Plus MultiTouch(1024x600)",
+		.max_x = 1024,
+		.max_y = 600,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+};
+
+static const struct usb_device_id dwav_usb_mt_devices[] = {
+	{USB_DEVICE(USB_VENDOR_ID_DWAV,   USB_DEVICE_ID_VU7),
+		.driver_info = ODROID_VU7},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5),
+		.driver_info = ODROID_VU5},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS),
+		.driver_info = ODROID_VU7PLUS},
+	{}
+};
+
+struct dwav_raw {                   /* Total 25 bytes */
+	unsigned char   header;     /* frame header 0xAA*/
+	unsigned char   press;
+	/* Touch flag (1:valid touch data, 0:touch finished) */
+	unsigned short  x1;         /* 1st x */
+	unsigned short  y1;         /* 1st y */
+	unsigned char   end;
+	/* 1st touch finish flags 0xBB, RPI only uses the first 7 bytes */
+	unsigned char   ids;        /* touch ID(bit field) */
+	unsigned short  y2;
+	unsigned short  x2;
+	unsigned short  y3;
+	unsigned short  x3;
+	unsigned short  y4;
+	unsigned short  x4;
+	unsigned short  y5;
+	unsigned short  x5;
+	unsigned char   tail;       /* frame end 0xCC */
+};
+
+#define	TS_EVENT_UNKNOWN	0x00
+#define	TS_EVENT_PRESS		0x01
+#define	TS_EVENT_RELEASE	0x02
+
+struct	finger_t	{
+	unsigned int	status;	/* ts event type */
+	unsigned int	x;	/* ts data x */
+	unsigned int	y;	/* ts data y */
+}	__packed;
+
+struct dwav_usb_mt  {
+	char		name[128], phys[64];
+
+	int		dev_id;
+	/* for URB Data DMA */
+	dma_addr_t	data_dma;
+	unsigned char	*data;
+	int		data_size;
+
+	struct urb		*irq;
+	struct usb_interface	*interface;
+	struct input_dev	*input;
+
+	struct finger_t		*finger;
+};
+
+static void dwav_usb_mt_report(struct dwav_usb_mt *dwav_usb_mt)
+{
+	int	id, max_x, max_y, max_press, max_finger;
+
+	max_x = DEV_INFO[dwav_usb_mt->dev_id].max_x;
+	max_y = DEV_INFO[dwav_usb_mt->dev_id].max_y;
+	max_press = DEV_INFO[dwav_usb_mt->dev_id].max_press;
+	max_finger = DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+
+	for (id = 0; id < max_finger; id++)	{
+
+		if (dwav_usb_mt->finger[id].status == TS_EVENT_UNKNOWN)
+			continue;
+
+		if (dwav_usb_mt->finger[id].x >= max_x ||
+		    dwav_usb_mt->finger[id].y >= max_y)
+			continue;
+
+		input_mt_slot(dwav_usb_mt->input, id);
+
+		if (dwav_usb_mt->finger[id].status != TS_EVENT_RELEASE) {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, true);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_X,
+					dwav_usb_mt->finger[id].x);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_Y,
+					dwav_usb_mt->finger[id].y);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_PRESSURE,
+					max_press);
+		} else {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, false);
+			dwav_usb_mt->finger[id].status = TS_EVENT_UNKNOWN;
+		}
+		input_mt_report_pointer_emulation(dwav_usb_mt->input, true);
+		input_sync(dwav_usb_mt->input);
+	}
+}
+
+static void dwav_usb_mt_process(struct dwav_usb_mt *dwav_usb_mt,
+		unsigned char *pkt, int len)
+{
+	struct  dwav_raw *dwav_raw = (struct dwav_raw *)pkt;
+	unsigned char bit_mask, cnt;
+
+	for (cnt = 0, bit_mask = 0x01;
+	     cnt < DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+	     cnt++, bit_mask <<= 1) {
+		if ((dwav_raw->ids & bit_mask) && dwav_raw->press) {
+			dwav_usb_mt->finger[cnt].status = TS_EVENT_PRESS;
+			switch (cnt) {
+			case	0:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x1);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y1);
+				break;
+			case	1:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x2);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y2);
+				break;
+			case	2:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x3);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y3);
+				break;
+			case	3:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x4);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y4);
+				break;
+			case	4:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x5);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y5);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (dwav_usb_mt->finger[cnt].status == TS_EVENT_PRESS)
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_RELEASE;
+			else
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_UNKNOWN;
+		}
+	}
+	dwav_usb_mt_report(dwav_usb_mt);
+}
+
+static void dwav_usb_mt_irq(struct urb *urb)
+{
+	struct dwav_usb_mt *dwav_usb_mt = urb->context;
+	struct device *dev = &dwav_usb_mt->interface->dev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ETIME:
+		/* this urb is timing out */
+		dev_dbg(dev, "%s - urb timed out - was the device unplugged?\n",
+				__func__);
+		return;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EPIPE:
+		/* this urb is terminated, clean up */
+		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
+				__func__, urb->status);
+		return;
+	default:
+		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
+				__func__, urb->status);
+		goto exit;
+	}
+
+	dwav_usb_mt_process(dwav_usb_mt, dwav_usb_mt->data, urb->actual_length);
+
+exit:
+	usb_mark_last_busy(interface_to_usbdev(dwav_usb_mt->interface));
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval) {
+		dev_err(dev, "%s - usb_submit_urb failed with result: %d\n",
+				__func__, retval);
+	}
+}
+
+static int dwav_usb_mt_open(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	dwav_usb_mt->irq->dev = interface_to_usbdev(dwav_usb_mt->interface);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface) ? -EIO : 0;
+	if (r < 0)
+		goto out;
+
+	if (usb_submit_urb(dwav_usb_mt->irq, GFP_KERNEL)) {
+		r = -EIO;
+		goto out_put;
+	}
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 1;
+out_put:
+	usb_autopm_put_interface(dwav_usb_mt->interface);
+out:
+	return r;
+}
+
+static void dwav_usb_mt_close(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface);
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 0;
+	if (!r)
+		usb_autopm_put_interface(dwav_usb_mt->interface);
+}
+
+static int dwav_usb_mt_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	return 0;
+}
+
+static int dwav_usb_mt_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int result = 0;
+
+	mutex_lock(&input->mutex);
+	if (input->users)
+		result = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return result;
+}
+
+static int dwav_usb_mt_reset_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int err = 0;
+
+	/* restart IO if needed */
+	mutex_lock(&input->mutex);
+	if (input->users)
+		err = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return err;
+}
+
+static void dwav_usb_mt_free_buffers(struct usb_device *udev,
+				  struct dwav_usb_mt *dwav_usb_mt)
+{
+	usb_free_coherent(udev, dwav_usb_mt->data_size,
+			dwav_usb_mt->data, dwav_usb_mt->data_dma);
+}
+
+static struct usb_endpoint_descriptor *dwav_usb_mt_get_input_endpoint(
+		struct usb_host_interface *interface)
+{
+	int i;
+
+	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
+		if (usb_endpoint_dir_in(&interface->endpoint[i].desc))
+			return &interface->endpoint[i].desc;
+	}
+
+	return NULL;
+}
+
+static int dwav_usb_mt_init(struct dwav_usb_mt *dwav_usb_mt, void *dev)
+{
+	int err;
+	struct input_dev *input_dev = (struct input_dev *)dev;
+
+	input_dev->name = dwav_usb_mt->name;
+	input_dev->phys = dwav_usb_mt->phys;
+
+	input_set_drvdata(input_dev, dwav_usb_mt);
+
+	input_dev->open = dwav_usb_mt_open;
+	input_dev->close = dwav_usb_mt_close;
+
+	input_dev->id.bustype = BUS_USB;
+
+	/* single touch */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+
+	/* multi touch */
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+	input_mt_init_slots(input_dev,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_finger, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		pr_err("%s - input_register_device failed, err: %d\n",
+				__func__, err);
+		return  err;
+	}
+
+	dwav_usb_mt->input = input_dev;
+
+	return  0;
+}
+
+static int dwav_usb_mt_probe(struct usb_interface *intf,
+			  const struct usb_device_id *id)
+{
+	struct dwav_usb_mt *dwav_usb_mt = NULL;
+	struct input_dev *input_dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int err = 0;
+
+	endpoint = dwav_usb_mt_get_input_endpoint(intf->cur_altsetting);
+	if (!endpoint)
+		return  -ENXIO;
+
+	dwav_usb_mt = kzalloc(sizeof(struct dwav_usb_mt), GFP_KERNEL);
+	if (!dwav_usb_mt)
+		return  -ENOMEM;
+
+	dwav_usb_mt->dev_id = id->driver_info;
+
+	dwav_usb_mt->finger = kzalloc(sizeof(struct finger_t) *
+				      DEV_INFO[dwav_usb_mt->dev_id].max_finger,
+				      GFP_KERNEL);
+
+	if (!dwav_usb_mt->finger)
+		goto err_free_mem;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err_free_mem;
+
+	dwav_usb_mt->data_size = sizeof(struct dwav_raw);
+	dwav_usb_mt->data = usb_alloc_coherent(udev, dwav_usb_mt->data_size,
+			GFP_KERNEL, &dwav_usb_mt->data_dma);
+	if (!dwav_usb_mt->data)
+		goto err_free_mem;
+
+	dwav_usb_mt->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dwav_usb_mt->irq) {
+		dev_dbg(&intf->dev,
+				"%s - usb_alloc_urb failed: usbtouch->irq\n",
+				__func__);
+		goto err_free_buffers;
+	}
+
+	if (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)   {
+		usb_fill_int_urb(dwav_usb_mt->irq, udev,
+			usb_rcvintpipe(udev, endpoint->bEndpointAddress),
+			dwav_usb_mt->data, dwav_usb_mt->data_size,
+			dwav_usb_mt_irq, dwav_usb_mt, endpoint->bInterval);
+	} else {
+		usb_fill_bulk_urb(dwav_usb_mt->irq, udev,
+			 usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),
+			 dwav_usb_mt->data, dwav_usb_mt->data_size,
+			 dwav_usb_mt_irq, dwav_usb_mt);
+	}
+
+	dwav_usb_mt->irq->dev = udev;
+	dwav_usb_mt->irq->transfer_dma = dwav_usb_mt->data_dma;
+	dwav_usb_mt->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	dwav_usb_mt->interface  = intf;
+
+	if (udev->manufacturer)
+		strlcpy(dwav_usb_mt->name,
+				udev->manufacturer, sizeof(dwav_usb_mt->name));
+
+	if (udev->product) {
+		if (udev->manufacturer)
+			strlcat(dwav_usb_mt->name,
+					" ", sizeof(dwav_usb_mt->name));
+
+		strlcat(dwav_usb_mt->name,
+				udev->product, sizeof(dwav_usb_mt->name));
+	}
+
+	if (!strlen(dwav_usb_mt->name)) {
+		snprintf(dwav_usb_mt->name, sizeof(dwav_usb_mt->name),
+				"D-WAV Scientific MultiTouch %04x:%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	usb_make_path(udev, dwav_usb_mt->phys, sizeof(dwav_usb_mt->phys));
+	strlcat(dwav_usb_mt->phys, "/input0", sizeof(dwav_usb_mt->phys));
+
+	usb_to_input_id(udev, &input_dev->id);
+
+	input_dev->dev.parent = &intf->dev;
+
+	err = dwav_usb_mt_init(dwav_usb_mt, (void *)input_dev);
+	if (err)
+		goto err_free_urb;
+
+	usb_set_intfdata(intf, dwav_usb_mt);
+
+	dev_info(&intf->dev, "%s\n", DEV_INFO[dwav_usb_mt->dev_id].name);
+
+	return 0;
+
+err_free_urb:
+	usb_free_urb(dwav_usb_mt->irq);
+
+err_free_buffers:
+	dwav_usb_mt_free_buffers(udev, dwav_usb_mt);
+
+err_free_mem:
+	if (input_dev)
+		input_free_device(input_dev);
+	kfree(dwav_usb_mt);
+
+	return err;
+}
+
+static void dwav_usb_mt_disconnect(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	if (!dwav_usb_mt)
+		return;
+
+	dev_dbg(&intf->dev,
+			"%s - dwav_usb_mt is initialized, cleaning up\n",
+			__func__);
+
+	usb_set_intfdata(intf, NULL);
+
+	/* this will stop IO via close */
+	input_unregister_device(dwav_usb_mt->input);
+
+	usb_free_urb(dwav_usb_mt->irq);
+
+	dwav_usb_mt_free_buffers(interface_to_usbdev(intf), dwav_usb_mt);
+
+	kfree(dwav_usb_mt);
+}
+
+MODULE_DEVICE_TABLE(usb, dwav_usb_mt_devices);
+
+static struct usb_driver dwav_usb_mt_driver = {
+	.name = "dwav_usb_mt",
+	.probe = dwav_usb_mt_probe,
+	.disconnect = dwav_usb_mt_disconnect,
+	.suspend = dwav_usb_mt_suspend,
+	.resume = dwav_usb_mt_resume,
+	.reset_resume = dwav_usb_mt_reset_resume,
+	.id_table = dwav_usb_mt_devices,
+	.supports_autosuspend = 1,
+};
+
+module_usb_driver(dwav_usb_mt_driver);
+
+MODULE_AUTHOR("Hardkernel Co.,Ltd");
+MODULE_DESCRIPTION("D-WAV USB(HID) MultiTouch Driver");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS("dwav_usb_mt");
diff -Naur a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
--- a/drivers/input/touchscreen/goodix.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/input/touchscreen/goodix.c	2023-05-04 11:23:57.056502325 -0400
@@ -1348,6 +1348,10 @@
 			return error;
 	}
 
+	client->irq = gpiod_to_irq(ts->gpiod_int);
+	if (client->irq)
+		dev_info(&client->dev, "GT911 irq number=%d\n", client->irq);
+
 	error = goodix_i2c_test(client);
 	if (error) {
 		if (!ts->reset_controller_at_probe &&
diff -Naur a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
--- a/drivers/input/touchscreen/Kconfig	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/input/touchscreen/Kconfig	2023-05-04 11:23:57.026502782 -0400
@@ -1379,4 +1379,14 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_DWAV_USB_MT
+	tristate "D-WAV Scientific USB MultiTouch"
+	depends on USB_ARCH_HAS_HCD
+	select USB
+	help
+	  Say Y here if you have a D-WAV Scientific USB(HID) based MultiTouch
+	  controller.
+
+	  module will be called dwav-usb-mt.
+
 endif
diff -Naur a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
--- a/drivers/input/touchscreen/Makefile	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/input/touchscreen/Makefile	2023-05-04 11:23:57.027502767 -0400
@@ -116,3 +116,4 @@
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_DWAV_USB_MT)	+= dwav-usb-mt.o
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c	2023-05-04 11:23:57.057502309 -0400
@@ -761,16 +761,23 @@
 	if (wol->wolopts) {
 		pr_info("stmmac: wakeup enable\n");
 		device_set_wakeup_enable(priv->device, 1);
-		enable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			enable_irq_wake(priv->wol_irq);
 	} else {
 		device_set_wakeup_enable(priv->device, 0);
-		disable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			disable_irq_wake(priv->wol_irq);
 	}
 
 	mutex_lock(&priv->lock);
 	priv->wolopts = wol->wolopts;
 	mutex_unlock(&priv->lock);
 
+	if (phy_ethtool_set_wol(dev->phydev, wol) == 0)
+		enable_irq_wake(dev->phydev->irq);
+	else
+		disable_irq_wake(dev->phydev->irq);
+
 	return 0;
 }
 
diff -Naur a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
--- a/drivers/net/phy/phy_device.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/net/phy/phy_device.c	2023-05-04 11:23:57.090501806 -0400
@@ -1781,8 +1781,10 @@
 	    phy_driver_is_genphy_10g(phydev))
 		device_release_driver(&phydev->mdio.dev);
 
-	/* Assert the reset signal */
-	phy_device_reset(phydev, 1);
+	if (!dev->wol_enabled) {
+		/* Assert the reset signal */
+		phy_device_reset(phydev, 1);
+	}
 
 	/*
 	 * The phydev might go away on the put_device() below, so avoid
diff -Naur a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
--- a/drivers/net/phy/realtek.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/net/phy/realtek.c	2023-05-04 11:23:57.138501073 -0400
@@ -12,6 +12,7 @@
 #include <linux/phy.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/etherdevice.h>
 
 #define RTL821x_PHYSR				0x11
 #define RTL821x_PHYSR_DUPLEX			BIT(13)
@@ -234,7 +235,13 @@
 
 		val = RTL8211F_INER_LINK_STATUS;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
+
+		// Pin 31 -> INTB
+		phy_modify_paged(phydev, 0xd40, 0x16, BIT(5), 0);
 	} else {
+		// Pin 31 -> PMEB
+		phy_modify_paged(phydev, 0xd40, 0x16, 0, BIT(5));
+
 		val = 0;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
 		if (err)
@@ -335,6 +342,34 @@
 			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
 }
 
+static int rtl8211f_set_wol(struct phy_device *phydev,
+		struct ethtool_wolinfo *wol)
+{
+	struct net_device *netdev = phydev->attached_dev;
+	const u8 *mac = (const u8 *)netdev->dev_addr;
+
+	if (wol->wolopts & ~(WAKE_MAGIC | WAKE_UCAST))
+		return -EOPNOTSUPP;
+
+	if (wol->wolopts & WAKE_UCAST) {
+		phy_write_paged(phydev, 0xd8c, 0x10, (mac[1] << 8) | mac[0]);
+		phy_write_paged(phydev, 0xd8c, 0x11, (mac[3] << 8) | mac[2]);
+		phy_write_paged(phydev, 0xd8c, 0x12, (mac[5] << 8) | mac[4]);
+	}
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		/* Set magic packet */
+		phy_write_paged(phydev, 0xd8a, 0x10, 0x1000);
+		phy_write_paged(phydev, 0xd8a, 0x11, 0x9fff);
+	} else {
+		/* Reset magic packet */
+		phy_write_paged(phydev, 0xd8a, 0x10, 0);
+		phy_modify_paged(phydev, 0xd8a, 0x11, BIT(15), 0);
+	}
+
+	return 0;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	struct rtl821x_priv *priv = phydev->priv;
@@ -929,6 +964,7 @@
 		.handle_interrupt = rtl8211f_handle_interrupt,
 		.suspend	= genphy_suspend,
 		.resume		= rtl821x_resume,
+		.set_wol	= rtl8211f_set_wol,
 		.read_page	= rtl821x_read_page,
 		.write_page	= rtl821x_write_page,
 	}, {
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c
--- a/drivers/pinctrl/meson/pinctrl-meson.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/pinctrl/meson/pinctrl-meson.c	2023-05-04 11:23:57.184500372 -0400
@@ -52,6 +52,7 @@
 #include <linux/property.h>
 #include <linux/regmap.h>
 #include <linux/seq_file.h>
+#include <linux/of_irq.h>
 
 #include "../core.h"
 #include "../pinctrl-utils.h"
@@ -602,6 +603,34 @@
 	return !!(val & BIT(bit));
 }
 
+static int meson_gpio_to_irq(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct meson_pinctrl *pc = gpiochip_get_data(chip);
+	struct meson_bank *bank;
+	struct irq_fwspec fwspec;
+	int hwirq;
+
+	if (meson_get_bank(pc, gpio, &bank))
+		return -EINVAL;
+
+	if (bank->irq_first < 0) {
+		dev_warn(pc->dev, "no support irq for pin[%d]\n", gpio);
+		return -EINVAL;
+	}
+	if (!pc->of_irq) {
+		dev_err(pc->dev, "invalid device node of gpio INTC\n");
+		return -EINVAL;
+	}
+
+	hwirq = gpio - bank->first + bank->irq_first;
+	fwspec.fwnode = of_node_to_fwnode(pc->of_irq);
+	fwspec.param_count = 2;
+	fwspec.param[0] = hwirq;
+	fwspec.param[1] = IRQ_TYPE_NONE;
+
+	return irq_create_fwspec_mapping(&fwspec);
+}
+
 static int meson_gpiolib_register(struct meson_pinctrl *pc)
 {
 	int ret;
@@ -617,6 +646,7 @@
 	pc->chip.direction_output = meson_gpio_direction_output;
 	pc->chip.get = meson_gpio_get;
 	pc->chip.set = meson_gpio_set;
+	pc->chip.to_irq = meson_gpio_to_irq;
 	pc->chip.base = -1;
 	pc->chip.ngpio = pc->data->num_pins;
 	pc->chip.can_sleep = false;
@@ -680,6 +710,12 @@
 	pc->fwnode = gpiochip_node_get_first(pc->dev);
 	gpio_np = to_of_node(pc->fwnode);
 
+	pc->of_irq = of_find_compatible_node(NULL,
+			NULL, "amlogic,meson-gpio-intc");
+	if (!pc->of_irq)
+		pc->of_irq = of_find_compatible_node(NULL,
+			NULL, "amlogic,meson-gpio-intc-ext");
+
 	pc->reg_mux = meson_map_resource(pc, gpio_np, "mux");
 	if (IS_ERR_OR_NULL(pc->reg_mux)) {
 		dev_err(pc->dev, "mux registers not found\n");
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson.h b/drivers/pinctrl/meson/pinctrl-meson.h
--- a/drivers/pinctrl/meson/pinctrl-meson.h	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/pinctrl/meson/pinctrl-meson.h	2023-05-04 11:23:57.222499792 -0400
@@ -134,6 +134,8 @@
 	struct regmap *reg_ds;
 	struct gpio_chip chip;
 	struct fwnode_handle *fwnode;
+	struct device_node *of_node;
+	struct device_node *of_irq;
 };
 
 #define FUNCTION(fn)							\
diff -Naur a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig
--- a/drivers/power/reset/Kconfig	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/power/reset/Kconfig	2023-05-04 11:23:57.262499181 -0400
@@ -9,6 +9,13 @@
 
 if POWER_RESET
 
+config POWER_RESET_ODROID
+	bool "odroid reboot/power-off driver"
+	depends on ARCH_MESON
+	help
+	  This driver supports restart / power off board for amlogic
+	  g12a/g12b/sm1 SoCs
+
 config POWER_RESET_AS3722
 	bool "ams AS3722 power-off driver"
 	depends on MFD_AS3722
diff -Naur a/drivers/power/reset/Makefile b/drivers/power/reset/Makefile
--- a/drivers/power/reset/Makefile	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/power/reset/Makefile	2023-05-04 11:23:57.298498632 -0400
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_POWER_RESET_ODROID) += odroid-reboot.o
 obj-$(CONFIG_POWER_RESET_AS3722) += as3722-poweroff.o
 obj-$(CONFIG_POWER_RESET_AT91_POWEROFF) += at91-poweroff.o
 obj-$(CONFIG_POWER_RESET_AT91_RESET) += at91-reset.o
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/power/reset/odroid-reboot.c	2023-05-04 11:23:57.339498007 -0400
@@ -0,0 +1,181 @@
+/*
+ * drivers/power/reset/odroid-reboot.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+
+#include <asm/system_misc.h>
+
+#include <asm/compiler.h>
+#include <linux/kdebug.h>
+#include <linux/arm-smccc.h>
+
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+int sd_vqsw;
+int sd_vmmc;
+int sd_vqen;
+
+static u32 psci_function_id_restart;
+static u32 psci_function_id_poweroff;
+
+#define CHECK_RET(ret) { \
+	if (ret) \
+	pr_err("[%s] gpio op failed(%d) at line %d\n",\
+			__func__, ret, __LINE__); \
+}
+
+static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+					 u64 arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id,
+			(unsigned long)arg0,
+			(unsigned long)arg1,
+			(unsigned long)arg2,
+			0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+void odroid_card_reset(void)
+{
+	int ret = 0;
+
+	if ((sd_vqsw == 0) && (sd_vmmc == 0))
+		return;
+
+	if (sd_vqen == 0) {
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vmmc);
+		ret = gpio_request_one(sd_vqsw,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(10);
+		ret = gpio_direction_output(sd_vqsw, 1);
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vmmc,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(10);
+		ret = gpio_direction_output(sd_vqsw, 0);
+		CHECK_RET(ret);
+		ret = gpio_direction_output(sd_vmmc, 1);
+		CHECK_RET(ret);
+		mdelay(5);
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vmmc);
+	} else {
+		gpio_free(sd_vqsw);
+		gpio_free(sd_vqen);
+		gpio_free(sd_vmmc);
+
+		ret = gpio_request_one(sd_vqsw,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vqen,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		ret = gpio_request_one(sd_vmmc,
+				GPIOF_OUT_INIT_LOW, "REBOOT");
+		CHECK_RET(ret);
+		mdelay(100);
+		ret = gpio_direction_input(sd_vqen);
+		CHECK_RET(ret);
+		ret = gpio_direction_input(sd_vmmc);
+		CHECK_RET(ret);
+		ret = gpio_direction_input(sd_vqsw);
+		CHECK_RET(ret);
+		mdelay(5);
+		gpio_free(sd_vqen);
+		gpio_free(sd_vmmc);
+		gpio_free(sd_vqsw);
+	}
+}
+
+static void do_odroid_restart(enum reboot_mode reboot_mode, const char *cmd)
+{
+	odroid_card_reset();
+	__invoke_psci_fn_smc(psci_function_id_restart,
+				0, 0, 0);
+}
+
+static void do_odroid_poweroff(void)
+{
+	odroid_card_reset();
+
+	__invoke_psci_fn_smc(0x82000042, 1, 0, 0);
+	__invoke_psci_fn_smc(psci_function_id_poweroff,
+				0, 0, 0);
+}
+
+static int odroid_restart_probe(struct platform_device *pdev)
+{
+	struct device_node *of_node;
+	u32 id;
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_reset", &id)) {
+		psci_function_id_restart = id;
+		arm_pm_restart = do_odroid_restart;
+	}
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_poweroff", &id)) {
+		psci_function_id_poweroff = id;
+		pm_power_off = do_odroid_poweroff;
+	}
+
+	of_node = pdev->dev.of_node;
+
+	sd_vqsw = of_get_named_gpio(of_node, "sd-vqsw", 0);
+	if (!gpio_is_valid(sd_vqsw)) sd_vqsw = 0;
+
+	sd_vmmc = of_get_named_gpio(of_node, "sd-vmmc", 0);
+	if (!gpio_is_valid(sd_vmmc)) sd_vmmc = 0;
+
+	sd_vqen = of_get_named_gpio(of_node, "sd-vqen", 0);
+	if (!gpio_is_valid(sd_vqen)) sd_vqen = 0;
+
+	return 0;
+}
+
+static const struct of_device_id of_odroid_restart_match[] = {
+	{ .compatible = "odroid,reboot", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_odroid_restart_match);
+
+static struct platform_driver odroid_restart_driver = {
+	.probe = odroid_restart_probe,
+	.driver = {
+		.name = "odroid-restart",
+		.of_match_table = of_match_ptr(of_odroid_restart_match),
+	},
+};
+
+static int __init odroid_restart_init(void)
+{
+	return platform_driver_register(&odroid_restart_driver);
+}
+device_initcall(odroid_restart_init);
diff -Naur a/drivers/pwm/core.c b/drivers/pwm/core.c
--- a/drivers/pwm/core.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/pwm/core.c	2023-05-04 11:23:57.412496893 -0400
@@ -235,8 +235,18 @@
 
 static bool pwm_ops_check(const struct pwm_chip *chip)
 {
+
 	const struct pwm_ops *ops = chip->ops;
 
+	/* driver supports legacy, non-atomic operation */
+	if (ops->config && ops->enable && ops->disable) {
+		if (IS_ENABLED(CONFIG_PWM_DEBUG))
+			dev_warn(chip->dev,
+				 "Driver needs updating to atomic API\n");
+
+		return true;
+	}
+
 	if (!ops->apply)
 		return false;
 
@@ -538,6 +548,73 @@
 	}
 }
 
+static int pwm_apply_legacy(struct pwm_chip *chip, struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	int err;
+	struct pwm_state initial_state = pwm->state;
+
+	if (state->polarity != pwm->state.polarity) {
+		if (!chip->ops->set_polarity)
+			return -EINVAL;
+
+		/*
+		 * Changing the polarity of a running PWM is only allowed when
+		 * the PWM driver implements ->apply().
+		 */
+		if (pwm->state.enabled) {
+			chip->ops->disable(chip, pwm);
+
+			/*
+			 * Update pwm->state already here in case
+			 * .set_polarity() or another callback depend on that.
+			 */
+			pwm->state.enabled = false;
+		}
+
+		err = chip->ops->set_polarity(chip, pwm, state->polarity);
+		if (err)
+			goto rollback;
+
+		pwm->state.polarity = state->polarity;
+	}
+
+	if (!state->enabled) {
+		if (pwm->state.enabled)
+			chip->ops->disable(chip, pwm);
+
+		return 0;
+	}
+
+	/*
+	 * We cannot skip calling ->config even if state->period ==
+	 * pwm->state.period && state->duty_cycle == pwm->state.duty_cycle
+	 * because we might have exited early in the last call to
+	 * pwm_apply_state because of !state->enabled and so the two values in
+	 * pwm->state might not be configured in hardware.
+	 */
+	err = chip->ops->config(pwm->chip, pwm,
+				state->duty_cycle,
+				state->period);
+	if (err)
+		goto rollback;
+
+	pwm->state.period = state->period;
+	pwm->state.duty_cycle = state->duty_cycle;
+
+	if (!pwm->state.enabled) {
+		err = chip->ops->enable(chip, pwm);
+		if (err)
+			goto rollback;
+	}
+
+	return 0;
+
+rollback:
+	pwm->state = initial_state;
+	return err;
+}
+
 /**
  * pwm_apply_state() - atomically apply a new state to a PWM device
  * @pwm: PWM device
@@ -570,7 +647,10 @@
 	    state->usage_power == pwm->state.usage_power)
 		return 0;
 
-	err = chip->ops->apply(chip, pwm, state);
+	if (chip->ops->apply)
+		err = chip->ops->apply(chip, pwm, state);
+	else
+		err = pwm_apply_legacy(chip, pwm, state);
 	if (err)
 		return err;
 
diff -Naur a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
--- a/drivers/pwm/Kconfig	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/pwm/Kconfig	2023-05-04 11:23:57.339498007 -0400
@@ -205,6 +205,21 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-fsl-ftm.
 
+config PWM_GPIO
+	tristate "Generic GPIO bit-banged PWM driver"
+	depends on OF
+	depends on GPIOLIB
+	help
+	  Some platforms do not offer any hardware PWM capabilities but do have
+	  General Purpose Input Output (GPIO) pins available. Using the kernels
+	  High-Resolution Timer API this driver tries to toggle GPIO using the
+	  generic kernel PWM framework. The maximum frequency and/or accuracy
+	  is dependent on several factors such as system load and the maximum
+	  speed a pin can be toggled at the hardware.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-gpio.
+
 config PWM_HIBVT
 	tristate "HiSilicon BVT PWM support"
 	depends on ARCH_HISI || COMPILE_TEST
diff -Naur a/drivers/pwm/Makefile b/drivers/pwm/Makefile
--- a/drivers/pwm/Makefile	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/pwm/Makefile	2023-05-04 11:23:57.373497488 -0400
@@ -17,6 +17,7 @@
 obj-$(CONFIG_PWM_DWC)		+= pwm-dwc.o
 obj-$(CONFIG_PWM_EP93XX)	+= pwm-ep93xx.o
 obj-$(CONFIG_PWM_FSL_FTM)	+= pwm-fsl-ftm.o
+obj-$(CONFIG_PWM_GPIO)		+= pwm-gpio.o
 obj-$(CONFIG_PWM_HIBVT)		+= pwm-hibvt.o
 obj-$(CONFIG_PWM_IMG)		+= pwm-img.o
 obj-$(CONFIG_PWM_IMX1)		+= pwm-imx1.o
--- /dev/null	2023-04-29 08:31:15.023562380 -0400
+++ b/drivers/pwm/pwm-gpio.c	2023-05-04 11:23:57.451496298 -0400
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) 2015 Olliver Schinagl <oliver@schinagl.nl>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This driver adds a high-resolution timer based PWM driver. Since this is a
+ * bit-banged driver, accuracy will always depend on a lot of factors, such as
+ * GPIO toggle speed and system load.
+ */
+
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/property.h>
+#include <linux/pwm.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#define DRV_NAME "pwm-gpio"
+
+struct gpio_pwm_data {
+	struct hrtimer timer;
+	struct gpio_desc *gpiod;
+	bool polarity;
+	bool pin_on;
+	int on_time;
+	int off_time;
+	bool run;
+};
+
+struct gpio_pwm_chip {
+	struct pwm_chip chip;
+};
+
+static void gpio_pwm_off(struct gpio_pwm_data *gpio_data)
+{
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 0 : 1);
+}
+
+static void gpio_pwm_on(struct gpio_pwm_data *gpio_data)
+{
+	gpiod_set_value_cansleep(gpio_data->gpiod, gpio_data->polarity ? 1 : 0);
+}
+
+enum hrtimer_restart gpio_pwm_timer(struct hrtimer *timer)
+{
+	struct gpio_pwm_data *gpio_data = container_of(timer,
+						      struct gpio_pwm_data,
+						      timer);
+	if (!gpio_data->run) {
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
+		return HRTIMER_NORESTART;
+	}
+
+	if (!gpio_data->pin_on) {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->on_time));
+		gpio_pwm_on(gpio_data);
+		gpio_data->pin_on = true;
+	} else {
+		hrtimer_forward_now(&gpio_data->timer,
+				    ns_to_ktime(gpio_data->off_time));
+		gpio_pwm_off(gpio_data);
+		gpio_data->pin_on = false;
+	}
+
+	return HRTIMER_RESTART;
+}
+
+static int gpio_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			    int duty_ns, int period_ns)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->on_time = duty_ns;
+	gpio_data->off_time = period_ns - duty_ns;
+
+	return 0;
+}
+
+static int gpio_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				 enum pwm_polarity polarity)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->polarity = (polarity != PWM_POLARITY_NORMAL) ? true : false;
+
+	return 0;
+}
+
+static int gpio_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	if (gpio_data->run)
+		return -EBUSY;
+
+	gpio_data->run = true;
+	if (gpio_data->off_time) {
+		hrtimer_start(&gpio_data->timer, ktime_set(0, 0),
+			      HRTIMER_MODE_REL);
+	} else {
+		if (gpio_data->on_time)
+			gpio_pwm_on(gpio_data);
+		else
+			gpio_pwm_off(gpio_data);
+	}
+
+	return 0;
+}
+
+static void gpio_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct gpio_pwm_data *gpio_data = pwm_get_chip_data(pwm);
+
+	gpio_data->run = false;
+	if (!gpio_data->off_time)
+		gpio_pwm_off(gpio_data);
+}
+
+static const struct pwm_ops gpio_pwm_ops = {
+	.config = gpio_pwm_config,
+	.set_polarity = gpio_pwm_set_polarity,
+	.enable = gpio_pwm_enable,
+	.disable = gpio_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int gpio_pwm_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct gpio_pwm_chip *gpio_chip;
+	int npwm, i;
+	int hrtimer = 0;
+
+	npwm = of_gpio_named_count(pdev->dev.of_node, "pwm-gpios");
+	if (npwm < 1)
+		return -ENODEV;
+
+	gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*gpio_chip), GFP_KERNEL);
+	if (!gpio_chip)
+		return -ENOMEM;
+
+	gpio_chip->chip.dev = &pdev->dev;
+	gpio_chip->chip.ops = &gpio_pwm_ops;
+	gpio_chip->chip.base = -1;
+	gpio_chip->chip.npwm = npwm;
+	gpio_chip->chip.of_xlate = of_pwm_xlate_with_flags;
+	gpio_chip->chip.of_pwm_n_cells = 3;
+
+	ret = pwmchip_add(&gpio_chip->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < npwm; i++) {
+		struct gpio_desc *gpiod;
+		struct gpio_pwm_data *gpio_data;
+
+		gpiod = devm_gpiod_get_index(&pdev->dev, "pwm", i,
+					     GPIOD_OUT_LOW);
+		if (IS_ERR(gpiod)) {
+			int error;
+
+			error = PTR_ERR(gpiod);
+			if (error != -EPROBE_DEFER)
+				dev_err(&pdev->dev,
+					"failed to get gpio flags, error: %d\n",
+					error);
+			return error;
+		}
+
+		gpio_data = devm_kzalloc(&pdev->dev, sizeof(*gpio_data),
+					 GFP_KERNEL);
+
+		hrtimer_init(&gpio_data->timer,
+			     CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		gpio_data->timer.function = &gpio_pwm_timer;
+		gpio_data->gpiod = gpiod;
+		gpio_data->pin_on = false;
+		gpio_data->run = false;
+
+		if (hrtimer_is_hres_active(&gpio_data->timer))
+			hrtimer++;
+
+		pwm_set_chip_data(&gpio_chip->chip.pwms[i], gpio_data);
+	}
+	if (!hrtimer) {
+		dev_warn(&pdev->dev, "unable to use High-Resolution timer,");
+		dev_warn(&pdev->dev, "%s is restricted to low resolution.",
+			 DRV_NAME);
+	}
+
+	platform_set_drvdata(pdev, gpio_chip);
+
+	dev_info(&pdev->dev, "%d gpio pwms loaded\n", npwm);
+
+	return 0;
+}
+
+static int gpio_pwm_remove(struct platform_device *pdev)
+{
+	struct gpio_pwm_chip *gpio_chip;
+	int i;
+
+	gpio_chip = platform_get_drvdata(pdev);
+	for (i = 0; i < gpio_chip->chip.npwm; i++) {
+		struct gpio_pwm_data *gpio_data;
+
+		gpio_data = pwm_get_chip_data(&gpio_chip->chip.pwms[i]);
+
+		hrtimer_cancel(&gpio_data->timer);
+	}
+
+	pwmchip_remove(&gpio_chip->chip);
+
+	return 0;
+}
+
+static const struct of_device_id gpio_pwm_of_match[] = {
+	{ .compatible = DRV_NAME, },
+	{/* sentinel */},
+};
+MODULE_DEVICE_TABLE(of, gpio_pwm_of_match);
+
+static struct platform_driver gpio_pwm_driver = {
+	.probe = gpio_pwm_probe,
+	.remove = gpio_pwm_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(gpio_pwm_of_match),
+	},
+};
+module_platform_driver(gpio_pwm_driver);
+
+MODULE_AUTHOR("Olliver Schinagl <oliver@schinagl.nl>");
+MODULE_DESCRIPTION("Generic GPIO bit-banged PWM driver");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/spi/spidev.c b/drivers/spi/spidev.c
--- a/drivers/spi/spidev.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/spi/spidev.c	2023-05-04 11:23:57.451496298 -0400
@@ -700,6 +700,7 @@
 	{ .name = "m53cpld" },
 	{ .name = "spi-petra" },
 	{ .name = "spi-authenta" },
+	{ .name = "spi-dev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
@@ -726,6 +727,7 @@
 	{ .compatible = "menlo,m53cpld", .data = &spidev_of_check },
 	{ .compatible = "cisco,spi-petra", .data = &spidev_of_check },
 	{ .compatible = "micron,spi-authenta", .data = &spidev_of_check },
+	{ .compatible = "odroid,spi-dev", .data = &spidev_of_check },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -Naur a/drivers/usb/dwc3/dwc3-of-simple.c b/drivers/usb/dwc3/dwc3-of-simple.c
--- a/drivers/usb/dwc3/dwc3-of-simple.c	2023-04-30 19:26:28.000000000 -0400
+++ b/drivers/usb/dwc3/dwc3-of-simple.c	2023-05-04 11:23:57.452496282 -0400
@@ -30,12 +30,16 @@
 	bool			need_reset;
 };
 
+struct dwc3_of_simple_data {
+	bool			need_reset;
+};
+
 static int dwc3_of_simple_probe(struct platform_device *pdev)
 {
 	struct dwc3_of_simple	*simple;
 	struct device		*dev = &pdev->dev;
 	struct device_node	*np = dev->of_node;
-
+	const struct dwc3_of_simple_data *data = of_device_get_match_data(dev);
 	int			ret;
 
 	simple = devm_kzalloc(dev, sizeof(*simple), GFP_KERNEL);
@@ -49,8 +53,8 @@
 	 * Some controllers need to toggle the usb3-otg reset before trying to
 	 * initialize the PHY, otherwise the PHY times out.
 	 */
-	if (of_device_is_compatible(np, "rockchip,rk3399-dwc3"))
-		simple->need_reset = true;
+	if (data->need_reset)
+		simple->need_reset = data->need_reset;
 
 	simple->resets = of_reset_control_array_get(np, false, true,
 						    true);
@@ -170,13 +174,34 @@
 			dwc3_of_simple_runtime_resume, NULL)
 };
 
+static const struct dwc3_of_simple_data dwc3_of_simple_data_rk3399 = {
+	.need_reset = true,
+};
+
 static const struct of_device_id of_dwc3_simple_match[] = {
-	{ .compatible = "rockchip,rk3399-dwc3" },
-	{ .compatible = "cavium,octeon-7130-usb-uctl" },
-	{ .compatible = "sprd,sc9860-dwc3" },
-	{ .compatible = "allwinner,sun50i-h6-dwc3" },
-	{ .compatible = "hisilicon,hi3670-dwc3" },
-	{ .compatible = "intel,keembay-dwc3" },
+	{
+		.compatible = "allwinner,sun50i-h6-dwc3",
+	},
+	{
+		.compatible = "cavium,octeon-7130-usb-uctl",
+	},
+	{
+		.compatible = "hisilicon,hi3670-dwc3",
+	},
+	{
+		.compatible = "intel,keembay-dwc3",
+	},
+	{
+		.compatible = "rockchip,rk3399-dwc3",
+		.data = &dwc3_of_simple_data_rk3399,
+	},
+	{
+		.compatible = "rockchip,rk3568-dwc3",
+		.data = &dwc3_of_simple_data_rk3399,
+	},
+	{
+		.compatible = "sprd,sc9860-dwc3",
+	},
 	{ /* Sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, of_dwc3_simple_match);
diff -Naur a/include/drm/drm_mipi_dbi.h b/include/drm/drm_mipi_dbi.h
--- a/include/drm/drm_mipi_dbi.h	2023-04-30 19:26:28.000000000 -0400
+++ b/include/drm/drm_mipi_dbi.h	2023-05-04 11:23:57.468496038 -0400
@@ -193,12 +193,7 @@
 #define mipi_dbi_command(dbi, cmd, seq...) \
 ({ \
 	const u8 d[] = { seq }; \
-	struct device *dev = &(dbi)->spi->dev;	\
-	int ret; \
-	ret = mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
-	if (ret) \
-		dev_err_ratelimited(dev, "error %d when sending command %#02x\n", ret, cmd); \
-	ret; \
+	mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
 })
 
 #ifdef CONFIG_DEBUG_FS
diff -Naur a/include/linux/pwm.h b/include/linux/pwm.h
--- a/include/linux/pwm.h	2023-04-30 19:26:28.000000000 -0400
+++ b/include/linux/pwm.h	2023-05-04 11:23:57.499495565 -0400
@@ -268,6 +268,10 @@
  *	       called once per PWM device when the PWM chip is
  *	       registered.
  * @owner: helps prevent removal of modules exporting active PWMs
+ * @config: configure duty cycles and period length for this PWM
+ * @set_polarity: configure the polarity of this PWM
+ * @enable: enable PWM output toggling
+ * @disable: disable PWM output toggling
  */
 struct pwm_ops {
 	int (*request)(struct pwm_chip *chip, struct pwm_device *pwm);
@@ -279,6 +283,14 @@
 	int (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm,
 			 struct pwm_state *state);
 	struct module *owner;
+
+	/* Only used by legacy drivers */
+	int (*config)(struct pwm_chip *chip, struct pwm_device *pwm,
+		      int duty_ns, int period_ns);
+	int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm,
+			    enum pwm_polarity polarity);
+	int (*enable)(struct pwm_chip *chip, struct pwm_device *pwm);
+	void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm);
 };
 
 /**
diff -Naur a/MAINTAINERS b/MAINTAINERS
--- a/MAINTAINERS	2023-04-30 19:26:28.000000000 -0400
+++ b/MAINTAINERS	2023-05-04 11:23:56.902504675 -0400
@@ -8577,6 +8577,11 @@
 F:	drivers/i2c/muxes/i2c-mux-gpio.c
 F:	include/linux/platform_data/i2c-mux-gpio.h
 
+GENERIC GPIO PWM DRIVER
+M:	Olliver Schinagl <oliver@schinagl.nl>
+S:	Maintained
+F:	drivers/pwm/pwm-gpio.c
+
 GENERIC HDLC (WAN) DRIVERS
 M:	Krzysztof Halasa <khc@pm.waw.pl>
 S:	Maintained
diff -Naur a/scripts/Makefile.dtbinst b/scripts/Makefile.dtbinst
--- a/scripts/Makefile.dtbinst	2023-04-30 19:26:28.000000000 -0400
+++ b/scripts/Makefile.dtbinst	2023-05-04 11:23:57.500495550 -0400
@@ -18,9 +18,10 @@
 include $(src)/Makefile
 
 dtbs    := $(addprefix $(dst)/, $(dtb-y) $(if $(CONFIG_OF_ALL_DTBS),$(dtb-)))
+dtbos   := $(addprefix $(dst)/, $(dtbo-y) $(if $(CONFIG_OF_ALL_DTBS),$(dtb-)))
 subdirs := $(addprefix $(obj)/, $(subdir-y) $(subdir-m))
 
-__dtbs_install: $(dtbs) $(subdirs)
+__dtbs_install: $(dtbs) $(dtbos) $(subdirs)
 	@:
 
 quiet_cmd_dtb_install = INSTALL $@
diff -Naur a/scripts/Makefile.lib b/scripts/Makefile.lib
--- a/scripts/Makefile.lib	2023-04-30 19:26:28.000000000 -0400
+++ b/scripts/Makefile.lib	2023-05-04 11:23:57.533495046 -0400
@@ -334,7 +334,7 @@
 # DTC
 # ---------------------------------------------------------------------------
 DTC ?= $(objtree)/scripts/dtc/dtc
-DTC_FLAGS += -Wno-interrupt_provider
+DTC_FLAGS += -Wno-interrupt_provider --symbol
 
 # Disable noisy checks by default
 ifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)
diff -Naur a/sound/soc/meson/axg-frddr.c b/sound/soc/meson/axg-frddr.c
--- a/sound/soc/meson/axg-frddr.c	2023-04-30 19:26:28.000000000 -0400
+++ b/sound/soc/meson/axg-frddr.c	2023-05-04 11:23:57.553494741 -0400
@@ -106,7 +106,7 @@
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
@@ -181,7 +181,7 @@
 	.name = "FRDDR",
 	.playback = {
 		.stream_name	= "Playback",
-		.channels_min	= 1,
+		.channels_min	= 2,
 		.channels_max	= AXG_FIFO_CH_MAX,
 		.rates		= AXG_FIFO_RATES,
 		.formats	= AXG_FIFO_FORMATS,
diff -Naur a/sound/soc/meson/Kconfig b/sound/soc/meson/Kconfig
--- a/sound/soc/meson/Kconfig	2023-04-30 19:26:28.000000000 -0400
+++ b/sound/soc/meson/Kconfig	2023-05-04 11:23:57.564494573 -0400
@@ -70,6 +70,8 @@
 	imply SND_MESON_AXG_PDM
 	imply SND_MESON_G12A_TOACODEC
 	imply SND_MESON_G12A_TOHDMITX if DRM_MESON_DW_HDMI
+	imply SND_SOC_MESON_T9015
+	imply SND_SOC_SIMPLE_AMPLIFIER
 	help
 	  Select Y or M to add support for the AXG SoC sound card
 

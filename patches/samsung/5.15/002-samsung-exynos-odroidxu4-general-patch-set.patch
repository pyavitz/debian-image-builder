From 9d582b6077117881a0ff537d688e3116f36f8ed4 Mon Sep 17 00:00:00 2001
From: Patrick Yavitz <pyavitz@xxxxx.com>
Date: Sat, 29 Jul 2023 10:49:38 -0400
Subject: [PATCH] samsung: exynos: odroidxu4: general patch set

Signed-off-by: Patrick Yavitz <pyavitz@xxxxx.com>
---
 arch/arm/kernel/setup.c                       |    2 +-
 arch/arm/mach-exynos/exynos.c                 |   28 +
 drivers/char/Kconfig                          |    9 +
 drivers/char/Makefile                         |    1 +
 drivers/char/exynos-gpiomem.c                 |  268 +++++
 drivers/devfreq/exynos-bus.c                  |   14 +-
 drivers/gpu/drm/exynos/exynos_hdmi.c          |  222 +++-
 drivers/gpu/drm/exynos/exynos_mixer.c         |   33 +-
 drivers/gpu/drm/tiny/Kconfig                  |   13 +
 drivers/gpu/drm/tiny/Makefile                 |    1 +
 drivers/gpu/drm/tiny/ili9341.c                |    2 +
 drivers/gpu/drm/tiny/ili9488_pio.c            |  366 ++++++
 drivers/hid/hid-ids.h                         |    4 +
 drivers/hid/hid-quirks.c                      |    3 +
 drivers/hwmon/pwm-fan.c                       |   67 +-
 drivers/input/touchscreen/Kconfig             |   10 +
 drivers/input/touchscreen/Makefile            |    1 +
 drivers/input/touchscreen/dwav-usb-mt.c       |  554 +++++++++
 drivers/input/touchscreen/goodix.c            |    4 +
 drivers/media/i2c/Kconfig                     |    7 +
 drivers/media/i2c/Makefile                    |    2 +
 drivers/media/i2c/lt8619c.c                   | 1030 +++++++++++++++++
 drivers/media/i2c/lt8619c.h                   |  107 ++
 drivers/media/platform/exynos-gsc/gsc-core.h  |    4 +-
 drivers/media/platform/s5p-jpeg/jpeg-core.c   |   45 +-
 drivers/media/platform/s5p-mfc/s5p_mfc.c      |    9 +-
 drivers/media/platform/s5p-mfc/s5p_mfc_dec.c  |    8 +-
 drivers/media/platform/s5p-mfc/s5p_mfc_enc.c  |    9 +
 drivers/mmc/host/dw_mmc-exynos.h              |    2 +-
 .../ethernet/stmicro/stmmac/stmmac_ethtool.c  |   11 +-
 drivers/net/phy/phy_device.c                  |    6 +-
 drivers/net/phy/realtek.c                     |   36 +
 drivers/regulator/s2mps11.c                   |   80 ++
 drivers/spi/spidev.c                          |    3 +
 drivers/thermal/samsung/exynos_tmu.c          |   18 +-
 drivers/thermal/thermal_helpers.c             |   28 +
 include/drm/drm_mipi_dbi.h                    |    7 +-
 37 files changed, 2956 insertions(+), 58 deletions(-)
 create mode 100644 drivers/char/exynos-gpiomem.c
 create mode 100644 drivers/gpu/drm/tiny/ili9488_pio.c
 create mode 100644 drivers/input/touchscreen/dwav-usb-mt.c
 create mode 100644 drivers/media/i2c/lt8619c.c
 create mode 100644 drivers/media/i2c/lt8619c.h

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 284a80c0b6e1..ae7a329a0c5a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -92,7 +92,7 @@ EXPORT_SYMBOL(cacheid);
 
 unsigned int __atags_pointer __initdata;
 
-unsigned int system_rev;
+unsigned int system_rev = 0x0100;
 EXPORT_SYMBOL(system_rev);
 
 const char *system_serial;
diff --git a/arch/arm/mach-exynos/exynos.c b/arch/arm/mach-exynos/exynos.c
index 51a247ca4da8..63fabfe5f692 100644
--- a/arch/arm/mach-exynos/exynos.c
+++ b/arch/arm/mach-exynos/exynos.c
@@ -221,3 +221,31 @@ DT_MACHINE_START(EXYNOS_DT, "Samsung Exynos (Flattened Device Tree)")
 	.dt_compat	= exynos_dt_compat,
 	.dt_fixup	= exynos_dt_fixup,
 MACHINE_END
+
+#define ODROID_MACHINE_START(name, compat)			\
+	DT_MACHINE_START(EXYNOS5422_ODROID_##name, "Hardkernel ODROID-"#name)	\
+		.l2c_aux_val	= 0x3c400001,			\
+		.l2c_aux_mask	= 0xc20fffff,			\
+		.smp		= smp_ops(exynos_smp_ops),	\
+		.map_io		= exynos_init_io,		\
+		.init_early	= exynos_firmware_init,		\
+		.init_irq	= exynos_init_irq,		\
+		.init_machine	= exynos_dt_machine_init,	\
+		.init_late	= exynos_pm_init,		\
+		.dt_compat	= compat,			\
+		.dt_fixup	= exynos_dt_fixup,		\
+	MACHINE_END
+
+static char const *const exynos5422_odroidxu3_dt_compat[] __initconst = {
+	"hardkernel,odroid-xu3",
+	"hardkernel,odroid-xu3-lite",
+	NULL,
+};
+
+static char const *const exynos5422_odroidxu4_dt_compat[] __initconst = {
+	"hardkernel,odroid-xu4",
+	NULL,
+};
+
+ODROID_MACHINE_START(XU3, exynos5422_odroidxu3_dt_compat)
+ODROID_MACHINE_START(XU4, exynos5422_odroidxu4_dt_compat)
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index d454428f4981..324e511e7e7c 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -464,4 +464,13 @@ config RANDOM_TRUST_BOOTLOADER
 	  believe its RNG facilities may be faulty. This may also be configured
 	  at boot time with "random.trust_bootloader=on/off".
 
+config EXYNOS_GPIOMEM
+	tristate "/dev/gpiomem rootless GPIO access via mmap() on the EXYNOS"
+	default m
+	help
+	  Provides users with root-free access to the GPIO registers
+	  on EXYNOS. Calling mmap(/dev/gpiomem) will map the GPIO register
+	  page to the user's pointer. This drvier can allow to access gpio
+	  memory area in user account.
+
 endmenu
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 264eb398fdd4..afedb86a8808 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -46,3 +46,4 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_XILLYBUS_CLASS)	+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-$(CONFIG_EXYNOS_GPIOMEM)	+= exynos-gpiomem.o
diff --git a/drivers/char/exynos-gpiomem.c b/drivers/char/exynos-gpiomem.c
new file mode 100644
index 000000000000..03ea4344346a
--- /dev/null
+++ b/drivers/char/exynos-gpiomem.c
@@ -0,0 +1,268 @@
+/*
+ * linux/drivers/char/exynos-gpiomem.c
+ *
+ * GPIO memory device driver
+ *
+ * Creates a chardev /dev/gpiomem which will provide user access to
+ * the EXYNOS's GPIO registers when it is mmap()'d.
+ * No longer need root for user GPIO access, but without relaxing permissions
+ * on /dev/mem.
+ *
+ * Copyright (c) 2017 Hardkernel Co., Ltd.
+ *
+ * This driver is based on bcm2835-gpiomem.c in Raspberrypi's linux kernel 4.4:
+ *	Written by Luke Wren <luke@raspberrypi.org>
+ *	Copyright (c) 2015, Raspberry Pi (Trading) Ltd.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The names of the above-listed copyright holders may not be used
+ *    to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2, as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/cdev.h>
+#include <linux/pagemap.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <asm/io.h>
+
+#define DEVICE_NAME "exynos-gpiomem"
+#define DRIVER_NAME "gpiomem-exynos"
+#define DEVICE_MINOR 0
+
+struct exynos_gpiomem_instance {
+	unsigned long gpio_regs_phys[32];
+	int gpio_area_count;
+	struct device *dev;
+};
+
+static struct cdev exynos_gpiomem_cdev;
+static dev_t exynos_gpiomem_devid;
+static struct class *exynos_gpiomem_class;
+static struct device *exynos_gpiomem_dev;
+static struct exynos_gpiomem_instance *inst;
+
+static int exynos_gpiomem_open(struct inode *inode, struct file *file)
+{
+	int dev = iminor(inode);
+	int ret = 0;
+
+	if (dev != DEVICE_MINOR) {
+		dev_err(inst->dev, "Unknown minor device: %d", dev);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+static int exynos_gpiomem_release(struct inode *inode, struct file *file)
+{
+	int dev = iminor(inode);
+	int ret = 0;
+
+	if (dev != DEVICE_MINOR) {
+		dev_err(inst->dev, "Unknown minor device %d", dev);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+static const struct vm_operations_struct exynos_gpiomem_vm_ops = {
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+	.access = generic_access_phys
+#endif
+};
+
+static int exynos_gpiomem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int gpio_area = 0;
+
+	while (gpio_area < inst->gpio_area_count) {
+		if ((inst->gpio_regs_phys[gpio_area] >> PAGE_SHIFT) == vma->vm_pgoff)
+			goto found;
+
+		gpio_area++;
+	}
+
+	return -EACCES;
+
+found:
+	vma->vm_page_prot = phys_mem_access_prot(file, vma->vm_pgoff,
+			PAGE_SIZE,
+			vma->vm_page_prot);
+
+	vma->vm_ops = &exynos_gpiomem_vm_ops;
+
+	if (remap_pfn_range(vma, vma->vm_start,
+				vma->vm_pgoff,
+				PAGE_SIZE,
+				vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static const struct file_operations
+exynos_gpiomem_fops = {
+	.owner = THIS_MODULE,
+	.open = exynos_gpiomem_open,
+	.release = exynos_gpiomem_release,
+	.mmap = exynos_gpiomem_mmap,
+};
+
+static int exynos_gpiomem_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct resource *res = NULL;
+	int i = 0;
+
+	/* Allocate buffers and instance data */
+	inst = kzalloc(sizeof(struct exynos_gpiomem_instance), GFP_KERNEL);
+
+	if (!inst) {
+		err = -ENOMEM;
+		goto failed_inst_alloc;
+	}
+
+	inst->dev = dev;
+
+	inst->gpio_area_count = of_property_count_elems_of_size(np, "reg",
+				sizeof(u32)) / 2;
+
+	if (inst->gpio_area_count > 32 || inst->gpio_area_count <= 0) {
+		dev_err(inst->dev, "failed to get gpio register area.");
+		err = -EINVAL;
+		goto failed_inst_alloc;
+	}
+
+	dev_info(inst->dev, "Initialised: GPIO register area is %d",
+			inst->gpio_area_count);
+
+	for (i = 0; i < inst->gpio_area_count; ++i) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (res) {
+			inst->gpio_regs_phys[i] = res->start;
+		} else {
+			dev_err(inst->dev, "failed to get IO resource");
+			err = -ENOENT;
+			goto failed_get_resource;
+		}
+	}
+
+	/* Create character device entries */
+	err = alloc_chrdev_region(&exynos_gpiomem_devid,
+				  DEVICE_MINOR, 1, DEVICE_NAME);
+	if (err != 0) {
+		dev_err(inst->dev, "unable to allocate device number");
+		goto failed_alloc_chrdev;
+	}
+	cdev_init(&exynos_gpiomem_cdev, &exynos_gpiomem_fops);
+	exynos_gpiomem_cdev.owner = THIS_MODULE;
+	err = cdev_add(&exynos_gpiomem_cdev, exynos_gpiomem_devid, 1);
+	if (err != 0) {
+		dev_err(inst->dev, "unable to register device");
+		goto failed_cdev_add;
+	}
+
+	/* Create sysfs entries */
+	exynos_gpiomem_class = class_create(THIS_MODULE, DEVICE_NAME);
+	err = IS_ERR(exynos_gpiomem_class);
+	if (err)
+		goto failed_class_create;
+
+	exynos_gpiomem_dev = device_create(exynos_gpiomem_class, NULL,
+					exynos_gpiomem_devid, NULL,
+					"gpiomem");
+	err = IS_ERR(exynos_gpiomem_dev);
+	if (err)
+		goto failed_device_create;
+
+	for (i = 0; i < inst->gpio_area_count; ++i) {
+		dev_info(inst->dev, "Initialised: Registers at 0x%08lx",
+				inst->gpio_regs_phys[i]);
+	}
+
+	return 0;
+
+failed_device_create:
+	class_destroy(exynos_gpiomem_class);
+failed_class_create:
+	cdev_del(&exynos_gpiomem_cdev);
+failed_cdev_add:
+	unregister_chrdev_region(exynos_gpiomem_devid, 1);
+failed_alloc_chrdev:
+failed_get_resource:
+	kfree(inst);
+failed_inst_alloc:
+	dev_err(inst->dev, "could not load exynos_gpiomem");
+	return err;
+}
+
+static int exynos_gpiomem_remove(struct platform_device *pdev)
+{
+	struct device *dev = inst->dev;
+
+	kfree(inst);
+	device_destroy(exynos_gpiomem_class, exynos_gpiomem_devid);
+	class_destroy(exynos_gpiomem_class);
+	cdev_del(&exynos_gpiomem_cdev);
+	unregister_chrdev_region(exynos_gpiomem_devid, 1);
+
+	dev_info(dev, "GPIO mem driver removed - OK");
+	return 0;
+}
+
+static const struct of_device_id exynos_gpiomem_of_match[] = {
+	{.compatible = "samsung,exynos-gpiomem",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, exynos_gpiomem_of_match);
+
+static struct platform_driver exynos_gpiomem_driver = {
+	.driver			= {
+		.name		= DRIVER_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= exynos_gpiomem_of_match,
+	},
+	.probe			= exynos_gpiomem_probe,
+	.remove			= exynos_gpiomem_remove,
+};
+
+module_platform_driver(exynos_gpiomem_driver);
+
+MODULE_ALIAS("platform:gpiomem-exynos");
+MODULE_DESCRIPTION("EXYNOS gpiomem driver for accessing GPIO from userspace");
+MODULE_AUTHOR("Brian Kim <brian.kim@hardkernel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/devfreq/exynos-bus.c b/drivers/devfreq/exynos-bus.c
index e689101abc93..061f36c00dd4 100644
--- a/drivers/devfreq/exynos-bus.c
+++ b/drivers/devfreq/exynos-bus.c
@@ -247,7 +247,7 @@ static int exynos_bus_parse_of(struct device_node *np,
 {
 	struct device *dev = bus->dev;
 	struct dev_pm_opp *opp;
-	unsigned long rate;
+	unsigned long rate, opp_rate;
 	int ret;
 
 	/* Get the clock to provide each bus with source clock */
@@ -271,13 +271,21 @@ static int exynos_bus_parse_of(struct device_node *np,
 	}
 
 	rate = clk_get_rate(bus->clk);
-
-	opp = devfreq_recommended_opp(dev, &rate, 0);
+	opp_rate = rate;
+	opp = devfreq_recommended_opp(dev, &opp_rate, 0);
 	if (IS_ERR(opp)) {
 		dev_err(dev, "failed to find dev_pm_opp\n");
 		ret = PTR_ERR(opp);
 		goto err_opp;
 	}
+	/*
+	 * FIXME: U-boot leaves clock source at incorrect PLL, this results
+	 * in clock rate outside defined OPP rate. Work around this bug by
+	 * setting clock rate to recommended one.
+	 */
+	if (rate > opp_rate)
+		clk_set_rate(bus->clk, opp_rate);
+
 	bus->curr_freq = dev_pm_opp_get_freq(opp);
 	dev_pm_opp_put(opp);
 
diff --git a/drivers/gpu/drm/exynos/exynos_hdmi.c b/drivers/gpu/drm/exynos/exynos_hdmi.c
index 7655142a4651..a270495ee293 100644
--- a/drivers/gpu/drm/exynos/exynos_hdmi.c
+++ b/drivers/gpu/drm/exynos/exynos_hdmi.c
@@ -145,6 +145,33 @@ struct hdmi_context {
 	bool				powered;
 };
 
+static bool gdvi_mode = false;
+static bool gEnableHPD = true;
+
+static int __init dvi_force_enable(char *str)
+{
+	if (!strcmp(str, "dvi")) {
+		gdvi_mode = true;
+		pr_info("hdmi: using DVI mode\n");
+	} else {
+		gdvi_mode = false;
+		pr_info("hdmi: using HDMI mode\n");
+	}
+
+	return 0;
+}
+__setup("vout=", dvi_force_enable);
+
+static int __init hdmi_hpd_enable(char *str)
+{
+	if (!strcmp(str, "false")) {
+		gEnableHPD = false;
+	}
+
+	return 0;
+}
+__setup("HPD=", hdmi_hpd_enable);
+
 static inline struct hdmi_context *encoder_to_hdmi(struct drm_encoder *e)
 {
 	return container_of(e, struct hdmi_context, encoder);
@@ -396,6 +423,38 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0xE3, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 31490000,
+		.conf = {
+			0x01, 0xD1, 0x34, 0x74, 0x44, 0x3C, 0x3A, 0xC2,
+			0x81, 0xE8, 0x3B, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0xC3, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 32000000,
+		.conf = {
+			0x01, 0x51, 0x28, 0x55, 0x44, 0x40, 0x00, 0xC8,
+			0x02, 0xC8, 0xF0, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x80, 0x25, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	/*
+	 * To support Vu5A, pixel clock 33.9MHz is needed
+	 * but we don't have the exact HDMI PHY table
+	 * so as a workaround, the closest table will be used.
+	 */
+	{
+		.pixel_clock = 33900000,
+		.conf = {
+			0x01, 0x51, 0x28, 0x55, 0x44, 0x40, 0x00, 0xC8,
+			0x02, 0xC8, 0xF0, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x80, 0x25, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 36000000,
 		.conf = {
@@ -414,6 +473,29 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x9A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	/*
+	 * To support Vu7A+, pixel clock 49MHz is needed
+	 * but we don't have the exact HDMI PHY table
+	 * so as a workaround, the closest table will be used.
+	 */
+	{
+		.pixel_clock = 49000000,
+		.conf = {
+			0x01, 0x51, 0x2A, 0x32, 0x42, 0x30, 0x00, 0xC4,
+			0x83, 0xE8, 0xFC, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x7A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 50400000,
+		.conf = {
+			0x01, 0x51, 0x2A, 0x32, 0x42, 0x30, 0x00, 0xC4,
+			0x83, 0xE8, 0xFC, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x7A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 65000000,
 		.conf = {
@@ -442,7 +524,7 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 		},
 	},
 	{
-		.pixel_clock = 74176000,
+		.pixel_clock = 74170000,
 		.conf = {
 			0x01, 0xD1, 0x1F, 0x10, 0x40, 0x5B, 0xEF, 0xC8,
 			0x81, 0xE8, 0xB9, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
@@ -459,6 +541,15 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0xA5, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 80140000,
+		.conf = {
+			0x01, 0xD1, 0x21, 0x11, 0x40, 0x3C, 0x2F, 0xC8,
+			0x87, 0xE8, 0xC8, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x99, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 83500000,
 		.conf = {
@@ -468,6 +559,24 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x4A, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 84750000,
+		.conf = {
+			0x01, 0xD1, 0x23, 0x11, 0x40, 0x30, 0x1E, 0xC7,
+			0x84, 0xE8, 0xD4, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x48, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 85860000,
+		.conf = {
+			0x01, 0xD1, 0x24, 0x11, 0x40, 0x30, 0xD2, 0xC8,
+			0x84, 0xE8, 0xD5, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x48, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 88750000,
 		.conf = {
@@ -477,6 +586,24 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x45, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 89750000,
+		.conf = {
+			0x01, 0xD1, 0x25, 0x11, 0x40, 0x30, 0x26, 0xC9,
+			0x83, 0xE8, 0xE0, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x89, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 104990000,
+		.conf = {
+			0x01, 0xD1, 0x2C, 0x12, 0x40, 0x78, 0xC3, 0xC2,
+			0x81, 0xE8, 0x06, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x3B, 0x24, 0x00, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 106500000,
 		.conf = {
@@ -486,6 +613,24 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x73, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 106560000,
+		.conf = {
+			0x01, 0xD1, 0x2C, 0x12, 0x40, 0x78, 0x73, 0xCA,
+			0x85, 0xE8, 0x0B, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x73, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 107800000,
+		.conf = {
+			0x01, 0x51, 0x2D, 0x15, 0x40, 0x01, 0x00, 0xC8,
+			0x82, 0xC8, 0x0E, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x66,
+			0x54, 0xC7, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 108000000,
 		.conf = {
@@ -504,6 +649,33 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x6A, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 119000000,
+		.conf = {
+			0x01, 0xD1, 0x31, 0x14, 0x40, 0x78, 0x41, 0xCB,
+			0x89, 0xE8, 0x28, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x68, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 122000000,
+		.conf = {
+			0x01, 0xD1, 0x33, 0x14, 0x40, 0x30, 0xF0, 0xC8,
+			0x85, 0xE8, 0x31, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x65, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 125590000,
+		.conf = {
+			0x01, 0xD1, 0x34, 0x14, 0x40, 0x78, 0x4F, 0xC2,
+			0x81, 0xE8, 0x3A, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x87, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 	{
 		.pixel_clock = 146250000,
 		.conf = {
@@ -531,6 +703,42 @@ static const struct hdmiphy_config hdmiphy_5420_configs[] = {
 			0x54, 0x3F, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,
 		},
 	},
+	{
+		.pixel_clock = 162000000,
+		.conf = {
+			0x01, 0xD1, 0x22, 0x01, 0x40, 0x30, 0xD4, 0xCD,
+			0x89, 0xE8, 0xC9, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x31, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 164100000,
+		.conf = {
+			0x01, 0xD1, 0x22, 0x89, 0x49, 0xB0, 0x15, 0xCE,
+			0x8A, 0xF8, 0xCD, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x2B, 0x25, 0x03, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 196900000,
+		.conf = {
+			0x01, 0xD1, 0x29, 0x1618, 0x418, 0x190, 0xF5, 0xCF,
+			0x8D, 0x168, 0xF5, 0xD8, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0xFA, 0x24, 0x03, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
+	{
+		.pixel_clock = 204800000,
+		.conf = {
+			0x01, 0xD1, 0x2B, 0x02, 0x40, 0x30, 0xE0, 0xC8,
+			0x85, 0xE8, 0x00, 0xD9, 0x45, 0xA0, 0xAC, 0x80,
+			0x08, 0x80, 0x09, 0x84, 0x05, 0x02, 0x24, 0x86,
+			0x54, 0x3C, 0x24, 0x01, 0x00, 0x00, 0x01, 0x80,
+		},
+	},
 };
 
 static const struct hdmiphy_config hdmiphy_5433_configs[] = {
@@ -854,6 +1062,9 @@ static enum drm_connector_status hdmi_detect(struct drm_connector *connector,
 {
 	struct hdmi_context *hdata = connector_to_hdmi(connector);
 
+	if (!gEnableHPD)
+		return connector_status_connected;
+
 	if (gpiod_get_value(hdata->hpd_gpio))
 		return connector_status_connected;
 
@@ -893,7 +1104,10 @@ static int hdmi_get_modes(struct drm_connector *connector)
 	if (!edid)
 		return -ENODEV;
 
-	hdata->dvi_mode = !drm_detect_hdmi_monitor(edid);
+	if (gdvi_mode)
+		hdata->dvi_mode = true;
+	else
+		hdata->dvi_mode = !drm_detect_hdmi_monitor(edid);
 	DRM_DEV_DEBUG_KMS(hdata->dev, "%s : width[%d] x height[%d]\n",
 			  (hdata->dvi_mode ? "dvi monitor" : "hdmi monitor"),
 			  edid->width_cm, edid->height_cm);
@@ -1593,6 +1807,9 @@ static int hdmi_audio_hw_params(struct device *dev, void *data,
 {
 	struct hdmi_context *hdata = dev_get_drvdata(dev);
 
+	if (hdata->dvi_mode)
+		return 0;
+
 	if (daifmt->fmt != HDMI_I2S || daifmt->bit_clk_inv ||
 	    daifmt->frame_clk_inv || daifmt->bit_clk_master ||
 	    daifmt->frame_clk_master) {
@@ -1968,6 +2185,7 @@ static int hdmi_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, hdata);
 
 	hdata->dev = dev;
+	hdata->dvi_mode = gdvi_mode;
 
 	mutex_init(&hdata->mutex);
 
diff --git a/drivers/gpu/drm/exynos/exynos_mixer.c b/drivers/gpu/drm/exynos/exynos_mixer.c
index 41c54f1f60bc..8eb6253518dd 100644
--- a/drivers/gpu/drm/exynos/exynos_mixer.c
+++ b/drivers/gpu/drm/exynos/exynos_mixer.c
@@ -315,23 +315,26 @@ static void mixer_cfg_gfx_blend(struct mixer_context *ctx, unsigned int win,
 	u32 val;
 
 	val  = MXR_GRP_CFG_COLOR_KEY_DISABLE; /* no blank key */
-	switch (pixel_alpha) {
-	case DRM_MODE_BLEND_PIXEL_NONE:
-		break;
-	case DRM_MODE_BLEND_COVERAGE:
-		val |= MXR_GRP_CFG_PIXEL_BLEND_EN;
-		break;
-	case DRM_MODE_BLEND_PREMULTI:
-	default:
-		val |= MXR_GRP_CFG_BLEND_PRE_MUL;
-		val |= MXR_GRP_CFG_PIXEL_BLEND_EN;
-		break;
-	}
+	if (win) {
+		switch (pixel_alpha) {
+		case DRM_MODE_BLEND_PIXEL_NONE:
+			break;
+		case DRM_MODE_BLEND_COVERAGE:
+			val |= MXR_GRP_CFG_PIXEL_BLEND_EN;
+			break;
+		case DRM_MODE_BLEND_PREMULTI:
+		default:
+			val |= MXR_GRP_CFG_BLEND_PRE_MUL;
+			val |= MXR_GRP_CFG_PIXEL_BLEND_EN;
+			break;
+		}
 
-	if (alpha != DRM_BLEND_ALPHA_OPAQUE) {
-		val |= MXR_GRP_CFG_WIN_BLEND_EN;
-		val |= win_alpha;
+		if (alpha != DRM_BLEND_ALPHA_OPAQUE) {
+			val |= MXR_GRP_CFG_WIN_BLEND_EN;
+			val |= win_alpha;
+		}
 	}
+
 	mixer_reg_writemask(ctx, MXR_GRAPHIC_CFG(win),
 			    val, MXR_GRP_CFG_MISC_MASK);
 }
diff --git a/drivers/gpu/drm/tiny/Kconfig b/drivers/gpu/drm/tiny/Kconfig
index d31be274a2bd..19638f4b0a71 100644
--- a/drivers/gpu/drm/tiny/Kconfig
+++ b/drivers/gpu/drm/tiny/Kconfig
@@ -119,6 +119,19 @@ config TINYDRM_ILI9486
 
 	  If M is selected the module will be called ili9486.
 
+config TINYDRM_ILI9488_PIO
+	tristate "DRM support for ILI9488 display panels (8bit PIO)"
+	depends on DRM
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_MIPI_DBI
+	select BACKLIGHT_CLASS_DEVICE
+	help
+	  DRM driver for th following Ilitek ILI9488 panels:
+          * Hardkernel 3.5" 480x320 TFT (HKTFT 3.5")
+
+	  If M is selected the module will be called hktft35.
+
 config TINYDRM_MI0283QT
 	tristate "DRM support for MI0283QT"
 	depends on DRM && SPI
diff --git a/drivers/gpu/drm/tiny/Makefile b/drivers/gpu/drm/tiny/Makefile
index e09942895c77..bc1512bd0eb5 100644
--- a/drivers/gpu/drm/tiny/Makefile
+++ b/drivers/gpu/drm/tiny/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_TINYDRM_HX8357D)		+= hx8357d.o
 obj-$(CONFIG_TINYDRM_ILI9225)		+= ili9225.o
 obj-$(CONFIG_TINYDRM_ILI9341)		+= ili9341.o
 obj-$(CONFIG_TINYDRM_ILI9486)		+= ili9486.o
+obj-$(CONFIG_TINYDRM_ILI9488_PIO)	+= ili9488_pio.o
 obj-$(CONFIG_TINYDRM_MI0283QT)		+= mi0283qt.o
 obj-$(CONFIG_TINYDRM_REPAPER)		+= repaper.o
 obj-$(CONFIG_TINYDRM_ST7586)		+= st7586.o
diff --git a/drivers/gpu/drm/tiny/ili9341.c b/drivers/gpu/drm/tiny/ili9341.c
index 37e0c33399c8..96f0d67b1702 100644
--- a/drivers/gpu/drm/tiny/ili9341.c
+++ b/drivers/gpu/drm/tiny/ili9341.c
@@ -162,12 +162,14 @@ static const struct drm_driver ili9341_driver = {
 
 static const struct of_device_id ili9341_of_match[] = {
 	{ .compatible = "adafruit,yx240qv29" },
+	{ .compatible = "hardkernel,hktft32" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9341_of_match);
 
 static const struct spi_device_id ili9341_id[] = {
 	{ "yx240qv29", 0 },
+	{ "hktft32", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(spi, ili9341_id);
diff --git a/drivers/gpu/drm/tiny/ili9488_pio.c b/drivers/gpu/drm/tiny/ili9488_pio.c
new file mode 100644
index 000000000000..f3a0b1fb885a
--- /dev/null
+++ b/drivers/gpu/drm/tiny/ili9488_pio.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * DRM driver for Hardkernel 3.5 ISP TFT display
+ *
+ * Copyright 2021 Dongjin Kim <tobetter@gmail.com>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-buf.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_damage_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_managed.h>
+#include <drm/drm_mipi_dbi.h>
+#include <drm/drm_rect.h>
+
+#define ILI9488_COLUMN_ADDR	0x2a
+#define ILI9488_PAGE_ADDR	0x2b
+#define ILI9488_MEMORY_WRITE	0x2c
+#define ILI9488_ITFCTR1         0xb0
+#define ILI9488_FRMCTR1		0xb1
+#define ILI9488_PWCTRL1         0xc2
+#define ILI9488_VMCTRL1         0xc5
+#define ILI9488_PGAMCTRL        0xe0
+#define ILI9488_NGAMCTRL        0xe1
+#define ILI9488_MADCTL_BGR      BIT(3)
+#define ILI9488_MADCTL_MV       BIT(5)
+#define ILI9488_MADCTL_MX       BIT(6)
+#define ILI9488_MADCTL_MY       BIT(7)
+
+struct ili9488_data {
+	struct mipi_dbi_dev *dbidev;
+	struct gpio_desc *wr;
+	struct gpio_desc *cs;
+	struct gpio_desc *db[8];
+	void __iomem *membase;
+	u32 mask;
+	u32 bits[8];
+	u32 bits_wr;
+};
+
+static struct ili9488_data *pdata;
+static u32 *rgb;
+
+static u32 ili9488_rgb565_to_gpiobus(struct ili9488_data *pdata, u8 color)
+{
+	int i;
+	u32 value = 0;
+
+	for (i = 0; i < 8; i++) {
+		if (color & 1)
+			value |= pdata->bits[i];
+		else
+			value &= ~(pdata->bits[i]);
+		color >>= 1;
+	}
+
+	return value;
+}
+
+static int ili9488_bus_write(struct mipi_dbi *dbi, u8 data)
+{
+	int i;
+
+	if (pdata->membase) {
+		u32 v = (readl(pdata->membase) & ~pdata->mask) | *(rgb + data);
+		writel(v, pdata->membase);
+		writel(v | pdata->bits_wr, pdata->membase);
+		return 0;
+	}
+
+	gpiod_set_value(pdata->wr, 0);
+	for (i = 0; i < 8; i++) {
+		gpiod_set_value(pdata->db[i], data & 1);
+		data >>= 1;
+	}
+	gpiod_set_value(pdata->wr, 1);
+
+	return 0;
+}
+
+static int ili9488_command(struct mipi_dbi *dbi, u8 *cmd, u8 *par, size_t num)
+{
+	u8 *p = par;
+
+	gpiod_set_value(dbi->dc, 0);
+	ili9488_bus_write(dbi, *cmd);
+	gpiod_set_value(dbi->dc, 1);
+
+	while (num--)
+		ili9488_bus_write(dbi, *p++);
+
+	return 0;
+}
+
+static void ili9488_pipe_enable(struct drm_simple_display_pipe *pipe,
+				struct drm_crtc_state *crtc_state,
+				struct drm_plane_state *plane_state)
+{
+	struct mipi_dbi_dev *dbidev = drm_to_mipi_dbi_dev(pipe->crtc.dev);
+	struct mipi_dbi *dbi = &dbidev->dbi;
+	u8 addr_mode;
+	int ret, idx;
+
+	if (!drm_dev_enter(pipe->crtc.dev, &idx))
+		return;
+
+	ret = mipi_dbi_poweron_reset(dbidev);
+	if (ret < 0)
+		goto out_exit;
+	if (ret == 1)
+		goto out_enable;
+
+	gpiod_set_value(pdata->cs, 0);
+
+	mipi_dbi_command(dbi, ILI9488_ITFCTR1, 0x00);
+	mipi_dbi_command(dbi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(250);
+
+	mipi_dbi_command(dbi, MIPI_DCS_SET_PIXEL_FORMAT, 0x55);
+	mipi_dbi_command(dbi, ILI9488_PWCTRL1, 0x33);
+	mipi_dbi_command(dbi, ILI9488_VMCTRL1, 0x00, 0x1e, 0x80, 0x00);
+	mipi_dbi_command(dbi, ILI9488_FRMCTR1, 0xb0, 0x11);
+	mipi_dbi_command(dbi, ILI9488_PGAMCTRL,
+			0x00, 0x04, 0x0e, 0x08, 0x17, 0x0a, 0x40, 0x79,
+			0x4d, 0x07, 0x0e, 0x0a, 0x1a, 0x1d, 0x0f);
+	mipi_dbi_command(dbi, ILI9488_NGAMCTRL,
+			0x00, 0x1b, 0x1f, 0x02, 0x10, 0x05, 0x32, 0x34,
+			0x43, 0x02, 0x0a, 0x09, 0x33, 0x37, 0x0f);
+	mipi_dbi_command(dbi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(100);
+
+ out_enable:
+	switch (dbidev->rotation) {
+		case 90:
+			addr_mode = ILI9488_MADCTL_MY;
+			break;
+		case 180:
+			addr_mode = ILI9488_MADCTL_MV;
+			break;
+		case 270:
+			addr_mode = ILI9488_MADCTL_MX;
+			break;
+		default:
+			addr_mode = ILI9488_MADCTL_MV | ILI9488_MADCTL_MY |
+				ILI9488_MADCTL_MX;
+			break;
+	}
+
+	addr_mode |= ILI9488_MADCTL_BGR;
+	mipi_dbi_command(dbi, MIPI_DCS_SET_ADDRESS_MODE, addr_mode);
+	mipi_dbi_enable_flush(dbidev, crtc_state, plane_state);
+
+out_exit:
+	drm_dev_exit(idx);
+}
+
+static const struct drm_simple_display_pipe_funcs ili9488_pipe_funcs = {
+	.enable = ili9488_pipe_enable,
+	.disable = mipi_dbi_pipe_disable,
+	.update = mipi_dbi_pipe_update,
+	.prepare_fb = drm_gem_simple_display_pipe_prepare_fb,
+};
+
+static const struct drm_display_mode ili9488_mode = {
+	DRM_SIMPLE_MODE(480, 320, 73, 49),
+};
+
+DEFINE_DRM_GEM_CMA_FOPS(ili9488_fops);
+
+static struct drm_driver ili9488_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
+	.fops			= &ili9488_fops,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
+	.name			= "ili9488",
+	.desc			= "Ilitek ILI9488",
+	.date			= "20210201",
+	.major			= 1,
+	.minor			= 0,
+};
+
+static int ili9488_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct mipi_dbi *dbi;
+	struct drm_device *drm;
+	struct mipi_dbi_dev *dbidev;
+	int ret;
+	int i;
+	u32 rotation = 0;
+	struct resource res;
+	char str[32];
+
+	pdata = devm_kzalloc(dev, sizeof(struct ili9488_data), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	dbidev = devm_drm_dev_alloc(dev, &ili9488_driver,
+			struct mipi_dbi_dev, drm);
+	if (IS_ERR(dbidev))
+		return PTR_ERR(dbidev);
+
+	dbi = &dbidev->dbi;
+	drm = &dbidev->drm;
+
+	dbi->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(dbi->reset)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'reset'\n");
+		return PTR_ERR(dbi->reset);
+	}
+
+	dbi->dc = devm_gpiod_get(dev, "dc", GPIOD_OUT_LOW);
+	if (IS_ERR(dbi->dc)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'dc'\n");
+		return PTR_ERR(dbi->dc);
+	}
+
+	pdata->wr = devm_gpiod_get(dev, "wr", GPIOD_OUT_HIGH);
+	if (IS_ERR(pdata->wr)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'wr'\n");
+		return PTR_ERR(pdata->wr);
+	}
+
+	pdata->cs = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->cs)) {
+		DRM_DEV_ERROR(dev, "Failed to get gpio 'cs'\n");
+		return PTR_ERR(pdata->cs);
+	}
+
+	for (i = 0; i < 8; i++) {
+		struct gpio_desc *desc;
+		int gpio = of_get_named_gpio(np, "db-gpios", i);
+		if (gpio < 0)
+			break;	/* FIXME */
+
+		desc = gpio_to_desc(gpio);
+
+		devm_gpio_request(dev, gpio, NULL);
+		gpiod_direction_output(desc, 1);
+
+		pdata->db[i] = desc;
+	}
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (!ret) {
+		pdata->membase = devm_ioremap(dev, res.start,
+				resource_size(&res));
+		if (!IS_ERR(pdata->membase)) {
+			for (i = 0; i < 8; i++) {
+				sprintf(str, "db-bits-%d", i);
+				ret = of_property_read_u32(np, str,
+						&pdata->bits[i]);
+				if (ret)
+					continue;
+				pdata->mask |= pdata->bits[i];
+			}
+
+			ret = of_property_read_u32(np, "db-bits-wr",
+					&pdata->bits_wr);
+			if (!ret)
+				pdata->mask |= pdata->bits_wr;
+		}
+	}
+
+	dbidev->backlight = devm_of_find_backlight(dev);
+	if (IS_ERR(dbidev->backlight))
+		return PTR_ERR(dbidev->backlight);
+
+	device_property_read_u32(dev, "rotation", &rotation);
+
+	rgb = devm_kzalloc(dev, sizeof(u32) * 256, GFP_KERNEL);
+	if (rgb) {
+		u32 *p = rgb;
+		for (i = 0; i < 256; i++)
+			*p++ = ili9488_rgb565_to_gpiobus(pdata, i);
+	}
+
+	gpiod_set_value(pdata->wr, 1);
+	gpiod_set_value(dbi->dc, 0);
+
+	/* override the command function set in  mipi_dbi_spi_init() */
+	dbi->command = ili9488_command;
+	dbi->read_commands = NULL;
+	dbi->swap_bytes = true;
+
+	ret = mipi_dbi_dev_init(dbidev, &ili9488_pipe_funcs,
+			&ili9488_mode, rotation);
+	if (ret)
+		return ret;
+
+	drm_mode_config_reset(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, pdata);
+	pdata->dbidev = dbidev;
+
+	drm_fbdev_generic_setup(drm, 0);
+
+	return 0;
+}
+
+static int ili9488_remove(struct platform_device *pdev)
+{
+	struct ili9488_data *pdata = platform_get_drvdata(pdev);
+	struct mipi_dbi_dev *dbidev = pdata->dbidev;
+	struct drm_device *drm = &dbidev->drm;
+
+	drm_dev_unplug(drm);
+	drm_atomic_helper_shutdown(drm);
+
+	return 0;
+}
+
+static const struct of_device_id ili9488_dt_ids[] = {
+	{ .compatible = "ili9488", 0 },
+	{ .compatible = "hardkernel,ili9488", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, ili9488_dt_ids);
+
+static struct platform_driver ili9488_platform_driver = {
+	.driver = {
+		.name = "ili9488",
+		.of_match_table = ili9488_dt_ids,
+	},
+	.probe = ili9488_probe,
+	.remove = ili9488_remove,
+};
+
+static int __init ili9488_init(void)
+{
+	return platform_driver_register(&ili9488_platform_driver);
+}
+
+static void __exit ili9488_exit(void)
+{
+	platform_driver_unregister(&ili9488_platform_driver);
+}
+
+module_init(ili9488_init);
+module_exit(ili9488_exit);
+
+MODULE_DESCRIPTION("Ilitek ILI9488 DRM driver (8bit PIO mode)");
+MODULE_AUTHOR("Dongjin Kim <tobetter@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 5daec769df7a..0fe966b54c6e 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1374,4 +1374,8 @@
 #define USB_VENDOR_ID_SIGNOTEC			0x2133
 #define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
 
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define USB_DEVICE_ID_VU5	0x0704
+#define USB_DEVICE_ID_VU7PLUS	0x0705
+
 #endif
diff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
index c7c06aa958c4..c8fccc1bb6b1 100644
--- a/drivers/hid/hid-quirks.c
+++ b/drivers/hid/hid-quirks.c
@@ -867,6 +867,9 @@ static const struct hid_device_id hid_ignore_list[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_SYNAPTICS, USB_DEVICE_ID_SYNAPTICS_DPAD) },
 #endif
 	{ HID_USB_DEVICE(USB_VENDOR_ID_YEALINK, USB_DEVICE_ID_YEALINK_P1K_P4K_B2K) },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS) },
 	{ }
 };
 
diff --git a/drivers/hwmon/pwm-fan.c b/drivers/hwmon/pwm-fan.c
index f12b9a28a232..383a24316985 100644
--- a/drivers/hwmon/pwm-fan.c
+++ b/drivers/hwmon/pwm-fan.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
@@ -44,6 +45,7 @@ struct pwm_fan_ctx {
 	unsigned int pwm_fan_max_state;
 	unsigned int *pwm_fan_cooling_levels;
 	struct thermal_cooling_device *cdev;
+	int enable;
 
 	struct hwmon_chip_info info;
 	struct hwmon_channel_info fan_channel;
@@ -99,6 +101,10 @@ static int  __set_pwm(struct pwm_fan_ctx *ctx, unsigned long pwm)
 	struct pwm_state *state = &ctx->pwm_state;
 
 	mutex_lock(&ctx->lock);
+
+	if (!ctx->enable)
+		pwm = MAX_PWM;
+
 	if (ctx->pwm_value == pwm)
 		goto exit_set_pwm_err;
 
@@ -183,6 +189,51 @@ static const struct hwmon_ops pwm_fan_hwmon_ops = {
 	.write = pwm_fan_write,
 };
 
+static ssize_t enable_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+	int err;
+	unsigned long val;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
+
+	mutex_lock(&ctx->lock);
+	ctx->enable = val;
+	mutex_unlock(&ctx->lock);
+
+	err = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[ctx->pwm_fan_state]);
+
+	return err ? err : count;
+}
+
+static ssize_t enable_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pwm_fan_ctx *ctx = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ctx->enable);
+}
+
+static SENSOR_DEVICE_ATTR_RW(pwm1_enable, enable, 0);
+
+static struct attribute *pwm_fan_attrs[] = {
+	&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group pwm_fan_group = {
+	.attrs = pwm_fan_attrs,
+};
+
+static const struct attribute_group *pwm_fan_groups[] = {
+	&pwm_fan_group,
+	NULL,
+};
+
 /* thermal cooling device callbacks */
 static int pwm_fan_get_max_state(struct thermal_cooling_device *cdev,
 				 unsigned long *state)
@@ -214,7 +265,7 @@ static int
 pwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)
 {
 	struct pwm_fan_ctx *ctx = cdev->devdata;
-	int ret;
+	int ret = 0;
 
 	if (!ctx || (state > ctx->pwm_fan_max_state))
 		return -EINVAL;
@@ -222,10 +273,12 @@ pwm_fan_set_cur_state(struct thermal_cooling_device *cdev, unsigned long state)
 	if (state == ctx->pwm_fan_state)
 		return 0;
 
-	ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
-	if (ret) {
-		dev_err(&cdev->device, "Cannot set pwm!\n");
-		return ret;
+	if (ctx->enable >= 2) {
+		ret = __set_pwm(ctx, ctx->pwm_fan_cooling_levels[state]);
+		if (ret) {
+			dev_err(&cdev->device, "Cannot set pwm!\n");
+			return ret;
+		}
 	}
 
 	ctx->pwm_fan_state = state;
@@ -316,6 +369,8 @@ static int pwm_fan_probe(struct platform_device *pdev)
 	if (IS_ERR(ctx->pwm))
 		return dev_err_probe(dev, PTR_ERR(ctx->pwm), "Could not get PWM\n");
 
+	ctx->enable = 2;
+
 	platform_set_drvdata(pdev, ctx);
 
 	ctx->reg_en = devm_regulator_get_optional(dev, "fan");
@@ -434,7 +489,7 @@ static int pwm_fan_probe(struct platform_device *pdev)
 	ctx->info.info = channels;
 
 	hwmon = devm_hwmon_device_register_with_info(dev, "pwmfan",
-						     ctx, &ctx->info, NULL);
+						     ctx, &ctx->info, pwm_fan_groups);
 	if (IS_ERR(hwmon)) {
 		dev_err(dev, "Failed to register hwmon device\n");
 		return PTR_ERR(hwmon);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index d4e74738c5a8..f96428569e19 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1366,4 +1366,14 @@ config TOUCHSCREEN_ZINITIX
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_DWAV_USB_MT
+	tristate "D-WAV Scientific USB MultiTouch"
+	depends on USB_ARCH_HAS_HCD
+	select USB
+	help
+	  Say Y here if you have a D-WAV Scientific USB(HID) based MultiTouch
+	  controller.
+
+	  module will be called dwav-usb-mt.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 7d34100f7f22..5a47f4e8c66a 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_DWAV_USB_MT)	+= dwav-usb-mt.o
diff --git a/drivers/input/touchscreen/dwav-usb-mt.c b/drivers/input/touchscreen/dwav-usb-mt.c
new file mode 100644
index 000000000000..2e1dd0f2986f
--- /dev/null
+++ b/drivers/input/touchscreen/dwav-usb-mt.c
@@ -0,0 +1,554 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * D-WAV Scientific USB(HID) MultiTouch Screen Driver(Based on usbtouchscreen.c)
+ *
+ * Copyright (C) Hardkernel, 2015
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+
+#include <linux/input/mt.h>
+
+#define USB_VENDOR_ID_DWAV	0x0eef	/* 800 x 480, 7" DWAV touch */
+#define USB_DEVICE_ID_VU7	0x0005
+
+#define USB_VENDOR_ID_ODROID	0x16b4
+#define	USB_DEVICE_ID_VU5	0x0704
+#define	USB_DEVICE_ID_VU7PLUS	0x0705
+
+enum	{
+	ODROID_VU7 = 0,	/* 800 x 480, 7" Touch */
+	ODROID_VU5,	/* 800 x 480, 5" Touch */
+	ODROID_VU7PLUS,	/* 1024 x 600, 7" Touch */
+};
+
+struct usbtouch_device_info	{
+	char	name[64];
+	int	max_x;
+	int	max_y;
+	int	max_press;
+	int	max_finger;
+};
+
+const struct usbtouch_device_info DEV_INFO[] = {
+	[ODROID_VU7] = {
+		.name = "ODROID VU7 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU5] = {
+		.name = "ODROID VU5 MultiTouch(800x480)",
+		.max_x = 800,
+		.max_y = 480,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+	[ODROID_VU7PLUS] = {
+		.name = "ODROID VU7 Plus MultiTouch(1024x600)",
+		.max_x = 1024,
+		.max_y = 600,
+		.max_press = 255,
+		.max_finger = 5,
+	},
+};
+
+static const struct usb_device_id dwav_usb_mt_devices[] = {
+	{USB_DEVICE(USB_VENDOR_ID_DWAV,   USB_DEVICE_ID_VU7),
+		.driver_info = ODROID_VU7},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU5),
+		.driver_info = ODROID_VU5},
+	{USB_DEVICE(USB_VENDOR_ID_ODROID, USB_DEVICE_ID_VU7PLUS),
+		.driver_info = ODROID_VU7PLUS},
+	{}
+};
+
+struct dwav_raw {                   /* Total 25 bytes */
+	unsigned char   header;     /* frame header 0xAA*/
+	unsigned char   press;
+	/* Touch flag (1:valid touch data, 0:touch finished) */
+	unsigned short  x1;         /* 1st x */
+	unsigned short  y1;         /* 1st y */
+	unsigned char   end;
+	/* 1st touch finish flags 0xBB, RPI only uses the first 7 bytes */
+	unsigned char   ids;        /* touch ID(bit field) */
+	unsigned short  y2;
+	unsigned short  x2;
+	unsigned short  y3;
+	unsigned short  x3;
+	unsigned short  y4;
+	unsigned short  x4;
+	unsigned short  y5;
+	unsigned short  x5;
+	unsigned char   tail;       /* frame end 0xCC */
+};
+
+#define	TS_EVENT_UNKNOWN	0x00
+#define	TS_EVENT_PRESS		0x01
+#define	TS_EVENT_RELEASE	0x02
+
+struct	finger_t	{
+	unsigned int	status;	/* ts event type */
+	unsigned int	x;	/* ts data x */
+	unsigned int	y;	/* ts data y */
+}	__packed;
+
+struct dwav_usb_mt  {
+	char		name[128], phys[64];
+
+	int		dev_id;
+	/* for URB Data DMA */
+	dma_addr_t	data_dma;
+	unsigned char	*data;
+	int		data_size;
+
+	struct urb		*irq;
+	struct usb_interface	*interface;
+	struct input_dev	*input;
+
+	struct finger_t		*finger;
+};
+
+static void dwav_usb_mt_report(struct dwav_usb_mt *dwav_usb_mt)
+{
+	int	id, max_x, max_y, max_press, max_finger;
+
+	max_x = DEV_INFO[dwav_usb_mt->dev_id].max_x;
+	max_y = DEV_INFO[dwav_usb_mt->dev_id].max_y;
+	max_press = DEV_INFO[dwav_usb_mt->dev_id].max_press;
+	max_finger = DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+
+	for (id = 0; id < max_finger; id++)	{
+
+		if (dwav_usb_mt->finger[id].status == TS_EVENT_UNKNOWN)
+			continue;
+
+		if (dwav_usb_mt->finger[id].x >= max_x ||
+		    dwav_usb_mt->finger[id].y >= max_y)
+			continue;
+
+		input_mt_slot(dwav_usb_mt->input, id);
+
+		if (dwav_usb_mt->finger[id].status != TS_EVENT_RELEASE) {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, true);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_X,
+					dwav_usb_mt->finger[id].x);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_POSITION_Y,
+					dwav_usb_mt->finger[id].y);
+			input_report_abs(dwav_usb_mt->input,
+					ABS_MT_PRESSURE,
+					max_press);
+		} else {
+			input_mt_report_slot_state(dwav_usb_mt->input,
+					MT_TOOL_FINGER, false);
+			dwav_usb_mt->finger[id].status = TS_EVENT_UNKNOWN;
+		}
+		input_mt_report_pointer_emulation(dwav_usb_mt->input, true);
+		input_sync(dwav_usb_mt->input);
+	}
+}
+
+static void dwav_usb_mt_process(struct dwav_usb_mt *dwav_usb_mt,
+		unsigned char *pkt, int len)
+{
+	struct  dwav_raw *dwav_raw = (struct dwav_raw *)pkt;
+	unsigned char bit_mask, cnt;
+
+	for (cnt = 0, bit_mask = 0x01;
+	     cnt < DEV_INFO[dwav_usb_mt->dev_id].max_finger;
+	     cnt++, bit_mask <<= 1) {
+		if ((dwav_raw->ids & bit_mask) && dwav_raw->press) {
+			dwav_usb_mt->finger[cnt].status = TS_EVENT_PRESS;
+			switch (cnt) {
+			case	0:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x1);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y1);
+				break;
+			case	1:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x2);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y2);
+				break;
+			case	2:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x3);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y3);
+				break;
+			case	3:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x4);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y4);
+				break;
+			case	4:
+				dwav_usb_mt->finger[cnt].x
+					= cpu_to_be16(dwav_raw->x5);
+				dwav_usb_mt->finger[cnt].y
+					= cpu_to_be16(dwav_raw->y5);
+				break;
+			default:
+				break;
+			}
+		} else {
+			if (dwav_usb_mt->finger[cnt].status == TS_EVENT_PRESS)
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_RELEASE;
+			else
+				dwav_usb_mt->finger[cnt].status
+					= TS_EVENT_UNKNOWN;
+		}
+	}
+	dwav_usb_mt_report(dwav_usb_mt);
+}
+
+static void dwav_usb_mt_irq(struct urb *urb)
+{
+	struct dwav_usb_mt *dwav_usb_mt = urb->context;
+	struct device *dev = &dwav_usb_mt->interface->dev;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ETIME:
+		/* this urb is timing out */
+		dev_dbg(dev, "%s - urb timed out - was the device unplugged?\n",
+				__func__);
+		return;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+	case -EPIPE:
+		/* this urb is terminated, clean up */
+		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
+				__func__, urb->status);
+		return;
+	default:
+		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
+				__func__, urb->status);
+		goto exit;
+	}
+
+	dwav_usb_mt_process(dwav_usb_mt, dwav_usb_mt->data, urb->actual_length);
+
+exit:
+	usb_mark_last_busy(interface_to_usbdev(dwav_usb_mt->interface));
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval) {
+		dev_err(dev, "%s - usb_submit_urb failed with result: %d\n",
+				__func__, retval);
+	}
+}
+
+static int dwav_usb_mt_open(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	dwav_usb_mt->irq->dev = interface_to_usbdev(dwav_usb_mt->interface);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface) ? -EIO : 0;
+	if (r < 0)
+		goto out;
+
+	if (usb_submit_urb(dwav_usb_mt->irq, GFP_KERNEL)) {
+		r = -EIO;
+		goto out_put;
+	}
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 1;
+out_put:
+	usb_autopm_put_interface(dwav_usb_mt->interface);
+out:
+	return r;
+}
+
+static void dwav_usb_mt_close(struct input_dev *input)
+{
+	struct dwav_usb_mt *dwav_usb_mt = input_get_drvdata(input);
+	int r;
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	r = usb_autopm_get_interface(dwav_usb_mt->interface);
+
+	dwav_usb_mt->interface->needs_remote_wakeup = 0;
+	if (!r)
+		usb_autopm_put_interface(dwav_usb_mt->interface);
+}
+
+static int dwav_usb_mt_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	usb_kill_urb(dwav_usb_mt->irq);
+
+	return 0;
+}
+
+static int dwav_usb_mt_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int result = 0;
+
+	mutex_lock(&input->mutex);
+	if (input->users)
+		result = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return result;
+}
+
+static int dwav_usb_mt_reset_resume(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+	struct input_dev *input = dwav_usb_mt->input;
+	int err = 0;
+
+	/* restart IO if needed */
+	mutex_lock(&input->mutex);
+	if (input->users)
+		err = usb_submit_urb(dwav_usb_mt->irq, GFP_NOIO);
+	mutex_unlock(&input->mutex);
+
+	return err;
+}
+
+static void dwav_usb_mt_free_buffers(struct usb_device *udev,
+				  struct dwav_usb_mt *dwav_usb_mt)
+{
+	usb_free_coherent(udev, dwav_usb_mt->data_size,
+			dwav_usb_mt->data, dwav_usb_mt->data_dma);
+}
+
+static struct usb_endpoint_descriptor *dwav_usb_mt_get_input_endpoint(
+		struct usb_host_interface *interface)
+{
+	int i;
+
+	for (i = 0; i < interface->desc.bNumEndpoints; i++) {
+		if (usb_endpoint_dir_in(&interface->endpoint[i].desc))
+			return &interface->endpoint[i].desc;
+	}
+
+	return NULL;
+}
+
+static int dwav_usb_mt_init(struct dwav_usb_mt *dwav_usb_mt, void *dev)
+{
+	int err;
+	struct input_dev *input_dev = (struct input_dev *)dev;
+
+	input_dev->name = dwav_usb_mt->name;
+	input_dev->phys = dwav_usb_mt->phys;
+
+	input_set_drvdata(input_dev, dwav_usb_mt);
+
+	input_dev->open = dwav_usb_mt_open;
+	input_dev->close = dwav_usb_mt_close;
+
+	input_dev->id.bustype = BUS_USB;
+
+	/* single touch */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+
+	/* multi touch */
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_x, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_y, 0, 0);
+	input_mt_init_slots(input_dev,
+			     DEV_INFO[dwav_usb_mt->dev_id].max_finger, 0);
+
+	err = input_register_device(input_dev);
+	if (err) {
+		pr_err("%s - input_register_device failed, err: %d\n",
+				__func__, err);
+		return  err;
+	}
+
+	dwav_usb_mt->input = input_dev;
+
+	return  0;
+}
+
+static int dwav_usb_mt_probe(struct usb_interface *intf,
+			  const struct usb_device_id *id)
+{
+	struct dwav_usb_mt *dwav_usb_mt = NULL;
+	struct input_dev *input_dev = NULL;
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_device *udev = interface_to_usbdev(intf);
+
+	int err = 0;
+
+	endpoint = dwav_usb_mt_get_input_endpoint(intf->cur_altsetting);
+	if (!endpoint)
+		return  -ENXIO;
+
+	dwav_usb_mt = kzalloc(sizeof(struct dwav_usb_mt), GFP_KERNEL);
+	if (!dwav_usb_mt)
+		return  -ENOMEM;
+
+	dwav_usb_mt->dev_id = id->driver_info;
+
+	dwav_usb_mt->finger = kzalloc(sizeof(struct finger_t) *
+				      DEV_INFO[dwav_usb_mt->dev_id].max_finger,
+				      GFP_KERNEL);
+
+	if (!dwav_usb_mt->finger)
+		goto err_free_mem;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err_free_mem;
+
+	dwav_usb_mt->data_size = sizeof(struct dwav_raw);
+	dwav_usb_mt->data = usb_alloc_coherent(udev, dwav_usb_mt->data_size,
+			GFP_KERNEL, &dwav_usb_mt->data_dma);
+	if (!dwav_usb_mt->data)
+		goto err_free_mem;
+
+	dwav_usb_mt->irq = usb_alloc_urb(0, GFP_KERNEL);
+	if (!dwav_usb_mt->irq) {
+		dev_dbg(&intf->dev,
+				"%s - usb_alloc_urb failed: usbtouch->irq\n",
+				__func__);
+		goto err_free_buffers;
+	}
+
+	if (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)   {
+		usb_fill_int_urb(dwav_usb_mt->irq, udev,
+			usb_rcvintpipe(udev, endpoint->bEndpointAddress),
+			dwav_usb_mt->data, dwav_usb_mt->data_size,
+			dwav_usb_mt_irq, dwav_usb_mt, endpoint->bInterval);
+	} else {
+		usb_fill_bulk_urb(dwav_usb_mt->irq, udev,
+			 usb_rcvbulkpipe(udev, endpoint->bEndpointAddress),
+			 dwav_usb_mt->data, dwav_usb_mt->data_size,
+			 dwav_usb_mt_irq, dwav_usb_mt);
+	}
+
+	dwav_usb_mt->irq->dev = udev;
+	dwav_usb_mt->irq->transfer_dma = dwav_usb_mt->data_dma;
+	dwav_usb_mt->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	dwav_usb_mt->interface  = intf;
+
+	if (udev->manufacturer)
+		strlcpy(dwav_usb_mt->name,
+				udev->manufacturer, sizeof(dwav_usb_mt->name));
+
+	if (udev->product) {
+		if (udev->manufacturer)
+			strlcat(dwav_usb_mt->name,
+					" ", sizeof(dwav_usb_mt->name));
+
+		strlcat(dwav_usb_mt->name,
+				udev->product, sizeof(dwav_usb_mt->name));
+	}
+
+	if (!strlen(dwav_usb_mt->name)) {
+		snprintf(dwav_usb_mt->name, sizeof(dwav_usb_mt->name),
+				"D-WAV Scientific MultiTouch %04x:%04x",
+				le16_to_cpu(udev->descriptor.idVendor),
+				le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	usb_make_path(udev, dwav_usb_mt->phys, sizeof(dwav_usb_mt->phys));
+	strlcat(dwav_usb_mt->phys, "/input0", sizeof(dwav_usb_mt->phys));
+
+	usb_to_input_id(udev, &input_dev->id);
+
+	input_dev->dev.parent = &intf->dev;
+
+	err = dwav_usb_mt_init(dwav_usb_mt, (void *)input_dev);
+	if (err)
+		goto err_free_urb;
+
+	usb_set_intfdata(intf, dwav_usb_mt);
+
+	dev_info(&intf->dev, "%s\n", DEV_INFO[dwav_usb_mt->dev_id].name);
+
+	return 0;
+
+err_free_urb:
+	usb_free_urb(dwav_usb_mt->irq);
+
+err_free_buffers:
+	dwav_usb_mt_free_buffers(udev, dwav_usb_mt);
+
+err_free_mem:
+	if (input_dev)
+		input_free_device(input_dev);
+	kfree(dwav_usb_mt);
+
+	return err;
+}
+
+static void dwav_usb_mt_disconnect(struct usb_interface *intf)
+{
+	struct dwav_usb_mt *dwav_usb_mt = usb_get_intfdata(intf);
+
+	if (!dwav_usb_mt)
+		return;
+
+	dev_dbg(&intf->dev,
+			"%s - dwav_usb_mt is initialized, cleaning up\n",
+			__func__);
+
+	usb_set_intfdata(intf, NULL);
+
+	/* this will stop IO via close */
+	input_unregister_device(dwav_usb_mt->input);
+
+	usb_free_urb(dwav_usb_mt->irq);
+
+	dwav_usb_mt_free_buffers(interface_to_usbdev(intf), dwav_usb_mt);
+
+	kfree(dwav_usb_mt);
+}
+
+MODULE_DEVICE_TABLE(usb, dwav_usb_mt_devices);
+
+static struct usb_driver dwav_usb_mt_driver = {
+	.name = "dwav_usb_mt",
+	.probe = dwav_usb_mt_probe,
+	.disconnect = dwav_usb_mt_disconnect,
+	.suspend = dwav_usb_mt_suspend,
+	.resume = dwav_usb_mt_resume,
+	.reset_resume = dwav_usb_mt_reset_resume,
+	.id_table = dwav_usb_mt_devices,
+	.supports_autosuspend = 1,
+};
+
+module_usb_driver(dwav_usb_mt_driver);
+
+MODULE_AUTHOR("Hardkernel Co.,Ltd");
+MODULE_DESCRIPTION("D-WAV USB(HID) MultiTouch Driver");
+MODULE_LICENSE("GPL");
+
+MODULE_ALIAS("dwav_usb_mt");
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index 166d36b2626e..6e0464744aef 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -1208,6 +1208,10 @@ static int goodix_ts_probe(struct i2c_client *client,
 			return error;
 	}
 
+	client->irq = gpiod_to_irq(ts->gpiod_int);
+	if (client->irq)
+		dev_info(&client->dev, "GT911 irq number=%d\n", client->irq);
+
 	error = goodix_i2c_test(client);
 	if (error) {
 		if (!ts->reset_controller_at_probe &&
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 6157e73eef24..64f894765ffa 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -1487,4 +1487,11 @@ config VIDEO_LM3646
 	  flash, torch LEDs.
 endmenu
 
+config LT8619C
+	tristate "LT8619c HDMI to LVDS Converter"
+	depends on OF
+	select REGMAP_I2C
+	help
+	  lt8619c chip driver.
+
 endif # VIDEO_V4L2
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 83268f20aa3a..a5c69b7e7db4 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -134,3 +134,5 @@ obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20.o
 obj-$(CONFIG_VIDEO_RDACM21)	+= rdacm21.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
+
+obj-$(CONFIG_LT8619C)		+= lt8619c.o
diff --git a/drivers/media/i2c/lt8619c.c b/drivers/media/i2c/lt8619c.c
new file mode 100644
index 000000000000..8c36667eb6e9
--- /dev/null
+++ b/drivers/media/i2c/lt8619c.c
@@ -0,0 +1,1030 @@
+/*
+ * LT8619C HDMI to LVDS converter + TFT-LCD 080-QC4011
+ *
+ * Copyright (C) 2020 Hardkernel Co., Ltd.
+ *
+ * Author : Joy Cho <joy.cho@hardkernel.com>
+ *
+ * The base initial code of this driver is from Lotium semiconductor
+ * and output signal of LT8619C is fixed as following.
+ *    - resolution 1024x768
+ *    - 1 port LVDS
+ *    - 8bit, DE timing mode
+ *
+ * FIXME for copyright notification and driver license level
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+
+#include "lt8619c.h"
+
+static struct _LT8619C_RXStatus RXStat, *pRXStat;
+
+static uint16_t h_active, v_active;
+static uint16_t h_syncwidth, v_syncwidth;
+static uint16_t h_bkporch, v_bkporch;
+static uint16_t h_total, v_total;
+static uint8_t h_syncpol, v_syncpol;
+static uint32_t frame_counter;
+
+/* onchip EDID */
+uint8_t onchip_edid[256] = {
+	/* 1024*768 */
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x21, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x0c, 0x1b, 0x01, 0x03, 0x80, 0x23, 0x1a, 0x78,
+	0xea, 0x5e, 0xc0, 0xa4, 0x59, 0x4a, 0x98, 0x25,
+	0x20, 0x50, 0x54, 0x00, 0x08, 0x00, 0x61, 0x40,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x64, 0x19,
+	0x00, 0x40, 0x41, 0x00, 0x26, 0x30, 0x08, 0x90,
+	0x36, 0x00, 0x63, 0x0a, 0x11, 0x00, 0x00, 0x18,
+	0x00, 0x00, 0x00, 0xff, 0x00, 0x4c, 0x69, 0x6e,
+	0x75, 0x78, 0x20, 0x23, 0x30, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x3b,
+	0x3d, 0x2f, 0x31, 0x07, 0x00, 0x0a, 0x20, 0x20,
+	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
+	0x00, 0x48, 0x4b, 0x5f, 0x56, 0x55, 0x38, 0x43,
+	0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x6a,
+
+	0x02, 0x03, 0x12, 0xf1, 0x23, 0x09, 0x07, 0x07,
+	0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0c, 0x00,
+	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6
+};
+
+/* lcd timing */
+struct video_timing lcd_timing = {
+	/* pix_clk/kHz, hfp, hs, hbp,hact,htotal,vfp, vs, vbp,vact, vtotal */
+	/* 1024x600p60 */
+	51200, 8, 144, 168, 1024, 1344, 3, 6, 26, 600, 635
+};
+
+struct lt8619c {
+	struct device *dev;
+	struct regmap *regmap;
+	struct i2c_client *client;
+	struct gpio_desc *gpiod_reset;
+};
+
+static struct lt8619c *lt8619c;
+
+static struct regmap_config lt8619c_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.name		= "lt8619c",
+};
+
+#define LT8619C_ADDR	0x32 /* 0x64 >> 1 */
+
+static uint8_t lt8619c_reg_read(char reg)
+{
+	uint8_t out_buf[2];
+	uint8_t in_buf[2];
+	uint8_t val;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = LT8619C_ADDR,
+			.flags = 0,
+			.len = 1,
+			.buf = out_buf,
+		},
+		{
+			.addr = LT8619C_ADDR,
+			.flags = I2C_M_RD,
+			.len = 1,
+			.buf = in_buf,
+		}
+	};
+
+	out_buf[0] = reg;
+	out_buf[1] = 0;
+
+	if (i2c_transfer(lt8619c->client->adapter, msgs, 2) == 2) {
+		val = in_buf[0];
+	} else {
+		dev_info(lt8619c->dev, "i2c 0x%02x 0x%02x read failed\n",
+			  reg, val);
+	}
+
+	return val;
+}
+
+static int lt8619c_reg_write(uint8_t reg, uint8_t data)
+{
+	uint8_t outbuf[2];
+	struct i2c_msg msg = {
+		.addr = LT8619C_ADDR,
+		.flags = 0,
+		.len = 2,
+		.buf = outbuf,
+	};
+
+	outbuf[0] = reg;
+	outbuf[1] = data;
+
+	if (i2c_transfer(lt8619c->client->adapter, &msg, 1) != 1)
+		dev_info(lt8619c->dev, "i2c 0x%02x 0x%02x write failed\n",
+			  reg, data);
+
+	return 0;
+}
+
+static int lt8619c_reg_write_bytes(uint8_t reg, uint8_t *data, uint16_t length)
+{
+	uint8_t outbuf[256 + 1];
+	struct i2c_msg msg = {
+		.addr = LT8619C_ADDR,
+		.flags = 0,
+		.len = sizeof(outbuf),
+		.buf = outbuf,
+	};
+
+	outbuf[0] = reg;
+	memcpy(outbuf + 1, data, length);
+
+	if (i2c_transfer(lt8619c->client->adapter, &msg, 1) != 1)
+		dev_info(lt8619c->dev, "i2c write failed\n");
+
+	return 0;
+}
+
+static bool lt8619c_check_chipid(void)
+{
+	unsigned int chip_id[3];
+
+	lt8619c_reg_write(0xff, 0x60);
+
+	chip_id[0] = lt8619c_reg_read(0x00);
+	chip_id[1] = lt8619c_reg_read(0x01);
+	chip_id[2] = lt8619c_reg_read(0x02);
+	dev_dbg(lt8619c->dev, "Read Chip : 0x%x, 0x%x, 0x%x\n",
+			chip_id[0], chip_id[1], chip_id[2]);
+
+	if ((chip_id[0] == 0x16) && chip_id[1] == 0x04)
+		return true;
+	else
+		return false;
+}
+
+static void lt8619c_setHPD(uint8_t level)
+{
+	lt8619c_reg_write(0xff, 0x80);
+
+	if (level)
+		lt8619c_reg_write(0x06, (lt8619c_reg_read(0x06) | 0x08));
+	else
+		lt8619c_reg_write(0x06, (lt8619c_reg_read(0x06) & 0xf7));
+}
+
+static void lt8619c_edid_calc(uint8_t *pbuf, struct video_timing *timing)
+{
+	uint16_t hblanking = 0;
+	uint16_t vblanking = 0;
+	uint16_t pixel_clk;
+
+	pixel_clk = timing->pixel_clk / 10;
+
+	if (pbuf == NULL || timing == NULL)
+		return;
+
+	hblanking = timing->hfp + timing->hs + timing->hbp; /* H blanking */
+	vblanking = timing->vfp + timing->vs + timing->vbp; /* V blanking */
+
+	pbuf[0] = pixel_clk % 256;
+	pbuf[1] = pixel_clk / 256;
+	pbuf[2] = timing->hact % 256;
+	pbuf[3] = hblanking % 256;
+	pbuf[4] = ((timing->hact / 256) << 4) + hblanking / 256;
+	pbuf[5] = timing->vact % 256;
+	pbuf[6] = vblanking % 256;
+	pbuf[7] = ((timing->vact / 256) << 4) + vblanking / 256;
+	pbuf[8] = timing->hfp % 256;
+	pbuf[9] = timing->hs % 256;
+	pbuf[10] = ((timing->vfp % 256) << 4) + timing->vs % 256;
+	pbuf[11] = ((timing->hfp/256) << 6) + ((timing->hs / 256) << 4)+
+		((timing->vfp / 256) << 2) + (timing->vs / 256);
+	pbuf[17] = 0x1c; /* progress negative vsync, negative hsync */
+}
+
+static uint8_t lt8619c_edid_checksum(uint8_t block, uint8_t *buf)
+{
+	uint8_t i = 0;
+	uint8_t checksum = 0;
+	uint8_t *pbuf = buf + 128 * block;
+
+	if (pbuf == NULL || (pbuf + 127) == NULL)
+		return 0;
+
+	for (i = 0, checksum = 0; i < 127 ; i++) {
+		checksum += pbuf[i];
+		checksum %= 256;
+	}
+	checksum = 256 - checksum;
+
+	dev_info(lt8619c->dev, "EDID checksum 0x%x\n", checksum);
+
+	return checksum;
+}
+
+static void lt8619c_set_edid(uint8_t *edid_buf)
+{
+	int ret = 0;
+
+	lt8619c_reg_write(0xff, 0x80);
+	lt8619c_reg_write(0x8e, 0x07);
+	lt8619c_reg_write(0x8f, 0x00);
+
+	if (edid_buf == NULL)
+		ret = lt8619c_reg_write_bytes(0x90, &onchip_edid[0], 256);
+	else
+		ret = lt8619c_reg_write_bytes(0x90, edid_buf, 256);
+
+	if (ret)
+		dev_info(lt8619c->dev, "EDID Set write error\n");
+
+	lt8619c_reg_write(0x8e, 0x02);
+}
+
+static void lt8619c_rx_init(void)
+{
+	lt8619c_reg_write(0xff, 0x80);
+	/* RGD_CLK_STABLE_OPT[1:0] */
+	lt8619c_reg_write(0x2c, (lt8619c_reg_read(0x2C)|0x30));
+
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x04, 0xF2);
+	lt8619c_reg_write(0x83, 0x3F);
+	lt8619c_reg_write(0x80, 0x08); /* use xtal_clk as sys_clk */
+#ifdef DDR_CLK
+	lt8619c_reg_write(0xa4, 0x14); /* 0x10:SDR clk,0x14: DDR clk */
+#else
+	lt8619c_reg_write(0xa4, 0x10); /* 0x10:SDR clk,0x14: DDR clk */
+#endif
+	dev_dbg(lt8619c->dev, "LT8619C output mode : %d\n", LT8619C_OUTPUTMODE);
+
+	dev_info(lt8619c->dev, "\nLT8619C set to OUTPUT_RGB888");
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x07, 0xff);
+	lt8619c_reg_write(0xa8, 0x0f);
+	lt8619c_reg_write(0x60, 0x00);
+	lt8619c_reg_write(0x96, 0x71);
+	lt8619c_reg_write(0xa0, 0x50);
+	// 0x60A3=0x44:Phase adjust enable;0x60A3=0x30:PIN68
+	// switch to output PCLK(only use for U5);
+	lt8619c_reg_write(0xa3, 0x74);
+	//Phase code value: 0x20,0x28,0x21,0x29,0x22,0x2a,0x23,0x2b,0x24,0x2c
+	lt8619c_reg_write(0xa2, 0x29);
+	//RGB mapping control
+	lt8619c_reg_write(0x6d, 0x00);//0x07//00
+	//RGB high/low bit swap control
+	lt8619c_reg_write(0x6e, 0x00);
+	/* LT8619C_OUTPUTMODE == OUTPUT_RGB888 */
+
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x0e, 0xfd);
+	lt8619c_reg_write(0x0e, 0xff);
+	lt8619c_reg_write(0x0d, 0xfc);
+	lt8619c_reg_write(0x0d, 0xff);
+}
+
+void lt8619c_audio_init(uint8_t audio_input)
+{
+	if (audio_input == I2S_2CH) {
+		dev_dbg(lt8619c->dev, "Audio Init : Audio set to I2S_2CH\n");
+		lt8619c_reg_write(0xff, 0x60);
+		lt8619c_reg_write(0x4c, 0x00);
+	} else if (audio_input == SPDIF) {
+		dev_dbg(lt8619c->dev, "Audio Init : Audio set to SPDIF\n");
+		lt8619c_reg_write(0xff, 0x60);
+		lt8619c_reg_write(0x4c, 0x80);
+	} else {
+		dev_dbg(lt8619c->dev, "Audio Init : Error! Check Audio Mode\n");
+	}
+
+	lt8619c_reg_write(0xff, 0x80);
+	lt8619c_reg_write(0x5d, 0xc9);
+	lt8619c_reg_write(0x07, 0x16);
+	lt8619c_reg_write(0x08, 0x80);
+}
+
+static void lt8619c_poweron(void)
+{
+	/* set HPD as low */
+	lt8619c_setHPD(0);
+
+	/* calculate timing & set edid */
+	lt8619c_edid_calc(onchip_edid + 0x36, &lcd_timing);
+	onchip_edid[127] = lt8619c_edid_checksum(0, &onchip_edid[0]);
+	lt8619c_set_edid(onchip_edid);
+
+	mdelay(100);
+
+	/* set HPD as low */
+	lt8619c_setHPD(1);
+
+	/* rx init */
+	lt8619c_rx_init();
+
+	/* audio init */
+	lt8619c_audio_init(I2S_2CH);
+
+	mdelay(1);
+}
+
+static void lt8619c_rx_reset(void)
+{
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x0e, 0xBF); /* reset RXPLL */
+	lt8619c_reg_write(0x09, 0xFD); /* reset RXPLL Lock det */
+	mdelay(5);
+
+	lt8619c_reg_write(0x0e, 0xff); /* release RXPLL */
+	lt8619c_reg_write(0x09, 0xff);
+
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x0e, 0xC7); /* reset PI */
+	lt8619c_reg_write(0x09, 0x0F); /* reset RX,CDR */
+	mdelay(10);
+
+	lt8619c_reg_write(0x0e, 0xff); /* release PI */
+	mdelay(10);
+	lt8619c_reg_write(0x09, 0x8F); /* release RX */
+	mdelay(10);
+	lt8619c_reg_write(0x09, 0xff); /* release CDR */
+	mdelay(50);
+}
+
+static bool lt8619c_detect_clk(void)
+{
+	uint8_t read_data;
+	bool ret;
+
+	ret = true;
+	lt8619c_reg_write(0xff, 0x80);
+	if (lt8619c_reg_read(0x44) & 0x08) {
+		if (!pRXStat->flag_RXClkStable) {
+			pRXStat->flag_RXClkStable =
+					!pRXStat->flag_RXClkStable;
+			dev_dbg(lt8619c->dev, "[detect_clk] rx clock stable %d\n",
+					pRXStat->flag_RXClkStable);
+			lt8619c_reg_write(0xff, 0x60);
+			read_data = lt8619c_reg_read(0x97);
+			lt8619c_reg_write(0x97, (read_data & 0x3f));
+			lt8619c_reg_write(0xff, 0x80);
+			lt8619c_reg_write(0x1b, 0x00);
+
+			lt8619c_rx_reset();
+			mdelay(5);
+
+			lt8619c_reg_write(0xff, 0x80);
+			read_data = (lt8619c_reg_read(0x87) & 0x10);
+			if (read_data) {
+				pRXStat->flag_RXPLLLocked = true;
+				dev_dbg(lt8619c->dev, "[detect_clk] clock detected & pll lock ok\n");
+				ret = true;
+			} else {
+				pRXStat->flag_RXPLLLocked = false;
+				memset(pRXStat, 0, sizeof(RXStat));
+				dev_dbg(lt8619c->dev, "[detect_clk] clock detected & pll unlock\n");
+				ret = false;
+			}
+		} else {
+			lt8619c_reg_write(0xff, 0x80);
+			read_data = lt8619c_reg_read(0x87) & 0x10;
+
+			if (read_data) {
+				pRXStat->flag_RXPLLLocked = true;
+				dev_dbg(lt8619c->dev, "[detect_clk] pll lock ok\n");
+				ret = true;
+			} else {
+				pRXStat->flag_RXPLLLocked = false;
+				memset(pRXStat, 0, sizeof(RXStat));
+				dev_dbg(lt8619c->dev, "[detect_clk] pll unlock\n");
+				ret = false;
+			}
+		}
+	} else {
+		if (pRXStat->flag_RXClkStable)
+			dev_dbg(lt8619c->dev, "[detect_clk] lt8619c clock disappeared\n");
+		memset(pRXStat, 0, sizeof(RXStat));
+		ret = false;
+	}
+	return ret;
+}
+
+static void lt8619c_input_info(void)
+{
+	uint8_t loop_num, read_data;
+
+	lt8619c_reg_write(0xff, 0x80);
+
+	if (pRXStat->flag_RXClkStable && pRXStat->flag_RXPLLLocked) {
+		dev_dbg(lt8619c->dev, "[input info] check hsync start:\n");
+
+		if (lt8619c_reg_read(0x13) & 0x01) {
+			if (!pRXStat->Flag_HsyncStable) {
+				pRXStat->Flag_HsyncStable = true;
+				for (loop_num = 0; loop_num < 8; loop_num++) {
+					dev_dbg(lt8619c->dev,
+						"[input info] check hsync : %d\n",
+						loop_num);
+					mdelay(20);
+
+					if (!(lt8619c_reg_read(0x13) & 0x01)) {
+						dev_dbg(lt8619c->dev, "[input info] lt8619c 8013[0]=0\n");
+						pRXStat->Flag_HsyncStable
+									= false;
+						dev_dbg(lt8619c->dev, "[input info] hsync stable FAIL\n");
+						break;
+					}
+				}
+
+				if (pRXStat->Flag_HsyncStable) {
+					lt8619c_reg_write(0xff, 0x60);
+					read_data = lt8619c_reg_read(0x0D);
+					 /* reset LVDS/BT fifo */
+					lt8619c_reg_write(0x0D,
+							read_data & 0xf8);
+					lt8619c_reg_write(0x0D,
+							read_data | 0x06);
+					lt8619c_reg_write(0x0D,
+							read_data | 0x01);
+					dev_dbg(lt8619c->dev, "[input info] hsync stable ok\n");
+				}
+			}
+		} else {
+			if (pRXStat->Flag_HsyncStable)
+				dev_dbg(lt8619c->dev, "[input info] hsync stable -> unstable\n");
+
+			pRXStat->Flag_HsyncStable = false;
+			dev_dbg(lt8619c->dev, "[input info] hsync keep unstable\n");
+		//memset(pRXStat, 0, sizeof(_RXStat));
+		}
+	}
+
+	if (pRXStat->Flag_HsyncStable) {
+		read_data = lt8619c_reg_read(0x13);
+		pRXStat->input_hdmimode =
+				(read_data & 0x02)?(true):(false);
+		if (pRXStat->input_hdmimode) {
+			pRXStat->input_vic = lt8619c_reg_read(0x74) & 0x7f;
+			pRXStat->input_colorspace =
+					lt8619c_reg_read(0x71) & 0x60;
+			pRXStat->input_colordepth =
+					lt8619c_reg_read(0x16) & 0xf0;
+			pRXStat->input_colorimetry =
+					lt8619c_reg_read(0x72) & 0xc0;
+			pRXStat->input_ex_colorimetry =
+					lt8619c_reg_read(0x73) & 0x70;
+			pRXStat->input_QuantRange =
+					lt8619c_reg_read(0x73) & 0x0c;
+			pRXStat->input_PRfactor =
+					lt8619c_reg_read(0x75) & 0x0f;
+
+			if (pRXStat->input_PRfactor == 1) {
+				lt8619c_reg_write(0xff, 0x60);
+				read_data = lt8619c_reg_read(0x97);
+				lt8619c_reg_write(0x97, read_data | 0x40);
+				lt8619c_reg_write(0xff, 0x80);
+				lt8619c_reg_write(0x1b, 0x20);
+			} else if (pRXStat->input_PRfactor == 3) {
+				lt8619c_reg_write(0xff, 0x60);
+				read_data = lt8619c_reg_read(0x97);
+				lt8619c_reg_write(0x97, read_data | 0x80);
+				lt8619c_reg_write(0xff, 0x80);
+				lt8619c_reg_write(0x1b, 0x60);
+			} else {
+				lt8619c_reg_write(0xff, 0x60);
+				read_data = lt8619c_reg_read(0x97);
+				lt8619c_reg_write(0x97, read_data & 0x3f);
+				lt8619c_reg_write(0xff, 0x80);
+				lt8619c_reg_write(0x1b, 0x00);
+			}
+		} else {
+			pRXStat->input_vic = 0;
+			pRXStat->input_colorspace = COLOR_RGB;
+			pRXStat->input_colordepth = 0;
+			pRXStat->input_colorimetry = ITU_709;
+			pRXStat->input_ex_colorimetry = 0;
+			pRXStat->input_QuantRange = FULL_RANGE;
+			pRXStat->input_PRfactor = 0;
+			lt8619c_reg_write(0xff, 0x60);
+			read_data = lt8619c_reg_read(0x97);
+			lt8619c_reg_write(0x97, read_data & 0x3f);
+			lt8619c_reg_write(0xff, 0x80);
+			lt8619c_reg_write(0x1b, 0x00);
+		}
+	}
+}
+
+static void lt8619c_csc_conversion(void)
+{
+	dev_dbg(lt8619c->dev, "[csc conv] output color 0x%x\n",
+						LT8619C_OUTPUTCOLOR);
+
+	lt8619c_reg_write(0xff, 0x60);
+	lt8619c_reg_write(0x07, 0xfe);
+
+	if (LT8619C_OUTPUTCOLOR == COLOR_RGB) {
+		if (pRXStat->input_colorspace == COLOR_RGB) {
+			lt8619c_reg_write(0x52, 0x00);
+			if (pRXStat->input_QuantRange == LIMIT_RANGE)
+				lt8619c_reg_write(0x53, 0x08);
+			else
+				lt8619c_reg_write(0x53, 0x00);
+		} else {
+			if (pRXStat->input_colorspace == COLOR_YCBCR422)
+				lt8619c_reg_write(0x52, 0x01);
+			else
+				lt8619c_reg_write(0x52, 0x00);
+
+			if (pRXStat->input_QuantRange == LIMIT_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x53, 0x50);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x53, 0x70);
+				else  /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x53, 0x70);
+			} else if (pRXStat->input_QuantRange == FULL_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x53, 0x40);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x53, 0x60);
+				else /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x53, 0x60);
+			} else {  /* DEFAULT_RANGE or RESERVED_VAL */
+				lt8619c_reg_write(0x53, 0x60);
+			}
+		}
+	} else if (LT8619C_OUTPUTCOLOR == COLOR_YCBCR444) {
+		if (pRXStat->input_colorspace == COLOR_RGB) {
+			lt8619c_reg_write(0x53, 0x00);
+			if (pRXStat->input_QuantRange == LIMIT_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x52, 0x08);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x52, 0x28);
+				else  /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x52, 0x28);
+			} else if (pRXStat->input_QuantRange == FULL_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x52, 0x18);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x52, 0x38);
+				else  /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x52, 0x38);
+			} else {  /* DEFAULT_RANGE or RESERVED_VAL */
+				lt8619c_reg_write(0x52, 0x38);
+			}
+		} else if (pRXStat->input_colorspace == COLOR_YCBCR444) {
+			lt8619c_reg_write(0x52, 0x00);
+			lt8619c_reg_write(0x53, 0x00);
+		} else if (pRXStat->input_colorspace == COLOR_YCBCR422) {
+			lt8619c_reg_write(0x52, 0x01);
+			lt8619c_reg_write(0x53, 0x00);
+		}
+	} else if (LT8619C_OUTPUTCOLOR == COLOR_YCBCR422) {
+		if (pRXStat->input_colorspace == COLOR_RGB) {
+			lt8619c_reg_write(0x53, 0x00);
+
+			if (pRXStat->input_QuantRange == LIMIT_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x52, 0x0a);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x52, 0x2a);
+				else  /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x52, 0x2a);
+			} else if (pRXStat->input_QuantRange ==	FULL_RANGE) {
+				if (pRXStat->input_colorimetry == ITU_601)
+					lt8619c_reg_write(0x52, 0x1a);
+				else if (pRXStat->input_colorimetry == ITU_709)
+					lt8619c_reg_write(0x52, 0x3a);
+				else  /* NO_DATA or EXTENDED_COLORIETRY */
+					lt8619c_reg_write(0x52, 0x3a);
+			} else {  /* DEFAULT_RANGE or RESERVED_VAL */
+				lt8619c_reg_write(0x52, 0x3a);
+			}
+		} else if (pRXStat->input_colorspace ==	COLOR_YCBCR444) {
+			lt8619c_reg_write(0x52, 0x02);
+			lt8619c_reg_write(0x53, 0x00);
+		} else if (pRXStat->input_colorspace == COLOR_YCBCR422) {
+			lt8619c_reg_write(0x52, 0x00);
+			lt8619c_reg_write(0x53, 0x00);
+		}
+	}
+}
+
+static void lt8619c_check_video(void)
+{
+	uint8_t tmp_read;
+
+	if (!pRXStat->Flag_HsyncStable) {
+		h_total = 0;
+		v_total = 0;
+		return;
+	}
+
+	lt8619c_reg_write(0xff, 0x60);
+
+	h_active = ((uint16_t)lt8619c_reg_read(0x22)) << 8;
+	h_active += lt8619c_reg_read(0x23);
+	v_active = ((uint16_t)(lt8619c_reg_read(0x20) & 0x0f)) << 8;
+	v_active += lt8619c_reg_read(0x21);
+
+	frame_counter = ((uint32_t)lt8619c_reg_read(0x10)) << 16;
+	frame_counter += ((uint32_t)lt8619c_reg_read(0x11)) << 8;
+	frame_counter += lt8619c_reg_read(0x12);
+
+	h_syncwidth = ((uint16_t)(lt8619c_reg_read(0x14) & 0x0f)) << 8;
+	h_syncwidth += lt8619c_reg_read(0x15);
+	v_syncwidth = lt8619c_reg_read(0x13);
+
+	h_bkporch = ((uint16_t)(lt8619c_reg_read(0x18) & 0x0f)) << 8;
+	h_bkporch += lt8619c_reg_read(0x19);
+	v_bkporch = lt8619c_reg_read(0x16);
+
+	h_total = ((uint16_t)lt8619c_reg_read(0x1e)) << 8;
+	h_total += lt8619c_reg_read(0x1f);
+	v_total = ((uint16_t)(lt8619c_reg_read(0x1c) & 0x0f)) << 8;
+	v_total += lt8619c_reg_read(0x1d);
+
+	tmp_read = lt8619c_reg_read(0x24);
+	h_syncpol = tmp_read & 0x01;
+	v_syncpol = (tmp_read & 0x02) >> 1;
+}
+
+static void detect_lvdspll_lock(void)
+{
+	uint8_t read_data_1;
+	uint8_t check_num = 0;
+
+	lt8619c_reg_write(0xff, 0x60);
+
+	if ((lt8619c_reg_read(0xA3) & 0x40) == 0x40) {
+		lt8619c_reg_write(0xff, 0x80);
+		while ((lt8619c_reg_read(0x87) & 0x20) == 0x00) {
+			lt8619c_reg_write(0xff, 0x60);
+			read_data_1 = lt8619c_reg_read(0x0e);
+			lt8619c_reg_write(0x0e, read_data_1 & 0xFD);
+
+			mdelay(5);
+
+			lt8619c_reg_write(0x0e, 0xff);
+			lt8619c_reg_write(0xff, 0x80);
+
+			check_num++;
+			if (check_num > 10)
+				break;
+		}
+	}
+}
+
+static void lt8619c_bt_setting(void)
+{
+	uint8_t val_6060;
+	uint16_t tmp_data;
+
+	if (!pRXStat->Flag_HsyncStable)
+		return;
+
+	detect_lvdspll_lock();
+
+	lt8619c_reg_write(0xff, 0x60);
+	val_6060 = lt8619c_reg_read(0x60) & 0xc7;
+
+	/* set BT TX h/vsync polarity */
+	if (h_syncpol)
+		val_6060 |= 0x20;
+
+	if (v_syncpol)
+		val_6060 |= 0x10;
+
+	/*
+	 * double the value of v_active&v_total
+	 * when input is interlace resolution.
+	 * if user needs to support interlace format not listed here,
+	 * please add that interlace format info here.
+	 */
+	if (pRXStat->input_hdmimode) {
+		switch (pRXStat->input_vic) {
+		case 5: /* 1080i */
+		case 6: /* 480i */
+		case 7: /* 480iH */
+		case 10: /* 480i4x */
+		case 11: /* 480i4xH */
+		case 20: /* 1080i25 */
+			dev_dbg(lt8619c->dev, "[bt setting] VIC20\n");
+			val_6060 |= 0x08;
+			v_active <<= 1;
+
+			if (v_total % 2 == 1)
+				v_total = (v_total << 1) - 1;
+			else
+				v_total = (v_total << 1) + 1;
+
+			lt8619c_reg_write(0x68, 23);
+			break;
+		case 21: /* 576i */
+		case 22: /* 576iH */
+		case 25: /* 576i4x */
+		case 26: /* 576i4xH */
+			dev_dbg(lt8619c->dev, "[bt setting] VIC26\n");
+			val_6060 |= 0x08;
+			v_active <<= 1;
+
+			if (v_total % 2 == 1)
+				v_total = (v_total << 1) - 1;
+			else
+				v_total = (v_total << 1) + 1;
+
+			lt8619c_reg_write(0x68, 25);
+			break;
+		default:
+			lt8619c_reg_write(0x68, 0x00);
+			break;
+		}
+	/* DVI Input */
+	} else {
+		if ((h_active == 1920) && (v_active == 540)) {
+			val_6060 |= 0x08;
+			v_active <<= 1;
+			if (v_total % 2 == 1)
+				v_total = (v_total << 1) - 1;
+			else
+				v_total = (v_total << 1) + 1;
+			lt8619c_reg_write(0x68, 23);
+		} else if ((h_active == 1440) && (v_active == 240)) {
+			val_6060 |= 0x08;
+			v_active <<= 1;
+			if (v_total % 2 == 1)
+				v_total = (v_total << 1) - 1;
+			else
+				v_total = (v_total << 1) + 1;
+			lt8619c_reg_write(0x68, 23);
+		} else if ((h_active == 1440) && (v_active == 288))	{
+			val_6060 |= 0x08;
+			v_active <<= 1;
+			if (v_total % 2 == 1)
+				v_total = (v_total << 1) - 1;
+			else
+				v_total = (v_total << 1) + 1;
+			lt8619c_reg_write(0x68, 25);
+		}
+	}
+
+	lt8619c_reg_write(0x60, val_6060);
+
+	tmp_data = h_syncwidth + h_bkporch;
+	lt8619c_reg_write(0x61, (uint8_t)(tmp_data >> 8));
+	lt8619c_reg_write(0x62, (uint8_t)tmp_data);
+
+	tmp_data = h_active;
+	lt8619c_reg_write(0x63, (uint8_t)(tmp_data >> 8));
+	lt8619c_reg_write(0x64, (uint8_t)tmp_data);
+
+	tmp_data = h_total;
+	lt8619c_reg_write(0x65, (uint8_t)(tmp_data >> 8));
+	lt8619c_reg_write(0x66, (uint8_t)tmp_data);
+
+	tmp_data = v_syncwidth + v_bkporch;
+	lt8619c_reg_write(0x67, (uint8_t)tmp_data);
+
+	tmp_data = v_active;
+	lt8619c_reg_write(0x69, (uint8_t)(tmp_data >> 8));
+	lt8619c_reg_write(0x6a, (uint8_t)tmp_data);
+
+	tmp_data = v_total;
+	lt8619c_reg_write(0x6b, (uint8_t)(tmp_data >> 8));
+	lt8619c_reg_write(0x6c, (uint8_t)tmp_data);
+}
+
+static void lt8619c_print_rxinfo(void)
+{
+	uint32_t clk = 0;
+	static uint16_t print_en;
+	uint32_t audio_rate = 0;
+
+	print_en = 0;
+
+	if (!pRXStat->Flag_HsyncStable) {
+		print_en = 0;
+		return;
+	}
+	if (print_en != 3)
+		print_en++;
+
+	if (print_en == 3) {
+		print_en = 0;
+
+		if (pRXStat->input_hdmimode) {
+			dev_dbg(lt8619c->dev, "[rxinfo] input is HDMI signal\n");
+			dev_dbg(lt8619c->dev, "[rxinfo] input vid %d\n",
+				pRXStat->input_vic);
+
+			if (pRXStat->input_colorspace == COLOR_RGB)
+				dev_dbg(lt8619c->dev,
+					"[rxinfo] input colorspace : COLOR_RGB\n");
+			else if (pRXStat->input_colorspace == COLOR_YCBCR444)
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorspace : COLOR_YCBCR444\n");
+			else if (pRXStat->input_colorspace == COLOR_YCBCR422)
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorspace : COLOR_YCBCR422\n");
+			else
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorspace UNKNOWN\n");
+
+			dev_info(lt8619c->dev, "[rxinfo] input colordepth %d\n",
+				pRXStat->input_colordepth);
+
+			if (pRXStat->input_colorimetry == NO_DATA)
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorimetry : NO DATA\n");
+			else if (pRXStat->input_colorimetry == ITU_601)
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorimetry : ITU 601\n");
+			else if (pRXStat->input_colorimetry == ITU_709)
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorimetry : ITU 709\n");
+			else
+				dev_dbg(lt8619c->dev, "[rxinfo] input colorimetry : extended colorimetry\n");
+
+			if (pRXStat->input_colorimetry == EXTENDED_COLORIETRY) {
+				if (pRXStat->input_ex_colorimetry == xvYCC601)
+					dev_dbg(lt8619c->dev, "[rxinfo] input ex colorimetry : xvYCC601\n");
+				else if
+					(pRXStat->input_ex_colorimetry ==
+								xvYCC709)
+					dev_dbg(lt8619c->dev,
+						"[rxinfo] input ex colorimetry : xvYCC709\n");
+				else
+					dev_dbg(lt8619c->dev,
+						"[rxinfo] input ex colorimetry : FUTURE COLORIMETRY\n");
+			}
+
+			if (pRXStat->input_QuantRange == DEFAULT_RANGE)
+				dev_dbg(lt8619c->dev,
+					"[rxinfo] input quant range : DEFAULT\n");
+			else if (pRXStat->input_QuantRange == LIMIT_RANGE)
+				dev_dbg(lt8619c->dev,
+					"[rxinfo] input quant range : LIMIT\n");
+			else if (pRXStat->input_QuantRange == FULL_RANGE)
+				dev_dbg(lt8619c->dev,
+					"[rxinfo] input quant range : FULL\n");
+			else
+				dev_dbg(lt8619c->dev,
+					"[rxinfo] input quant range : RESERVED\n");
+
+			dev_info(lt8619c->dev, "[rxinfo] input PRfactor %d\n",
+				pRXStat->input_PRfactor);
+		} else {
+			dev_dbg(lt8619c->dev, "[rxinfo] input : DVI signal\n");
+		}
+
+		dev_dbg(lt8619c->dev, "[rxinfo] input timing info\n");
+
+		lt8619c_reg_write(0xff, 0x80);
+		clk = lt8619c_reg_read(0x44)&0x07;
+		clk <<= 8;
+		clk += lt8619c_reg_read(0x45);
+		clk <<= 8;
+		clk += lt8619c_reg_read(0x46);
+
+		dev_dbg(lt8619c->dev,
+			"[rxinfo] TMDS clock freq : %d kHz\n", clk);
+
+		dev_dbg(lt8619c->dev, "[rxinfo] h_active %d\n",
+							h_active);
+		dev_dbg(lt8619c->dev, "[rxinfo] v_active %d\n",
+							v_active);
+		dev_dbg(lt8619c->dev, "[rxinfo] h_syncwidth %d\n",
+							h_syncwidth);
+		dev_dbg(lt8619c->dev, "[rxinfo] v_syncwidth %d\n",
+							v_syncwidth);
+		dev_dbg(lt8619c->dev, "[rxinfo] h_bkporch %d\n",
+							h_bkporch);
+		dev_dbg(lt8619c->dev, "[rxinfo] v_bkporch %d\n",
+							v_bkporch);
+		dev_dbg(lt8619c->dev, "[rxinfo] h_total %d\n", h_total);
+		dev_dbg(lt8619c->dev, "[rxinfo] v_total %d\n", v_total);
+		dev_dbg(lt8619c->dev, "[rxinfo] frame_counter %d\n",
+							frame_counter);
+
+		if (h_syncpol)
+			dev_dbg(lt8619c->dev, "[rxinfo] h_syncpol is positive\n");
+		else
+			dev_dbg(lt8619c->dev, "[rxinfo] h_syncpol is negative\n");
+
+		if (v_syncpol)
+			dev_dbg(lt8619c->dev, "[rxinfo] v_syncpol is positive\n");
+		else
+			dev_dbg(lt8619c->dev, "[rxinfo] v_syncpol is negative\n");
+
+		lt8619c_reg_write(0xff, 0x80);
+		audio_rate = ((lt8619c_reg_read(0x11)&0x03) * 0x100) +
+						lt8619c_reg_read(0x12);
+		dev_dbg(lt8619c->dev, "[rxinfo] audio rate %d kHz\n",
+						audio_rate);
+	}
+}
+
+static int lt8619c_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+
+	lt8619c = devm_kzalloc(dev, sizeof(*lt8619c), GFP_KERNEL);
+	if (!lt8619c)
+		return -ENOMEM;
+
+	lt8619c->dev = dev;
+	lt8619c->client = client;
+
+	lt8619c->regmap = devm_regmap_init_i2c(client, &lt8619c_regmap_config);
+	if (IS_ERR(lt8619c->regmap))
+		return PTR_ERR(lt8619c->regmap);
+
+	/* Reset GPIO */
+	lt8619c->gpiod_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(lt8619c->gpiod_reset))
+		return PTR_ERR(lt8619c->gpiod_reset);
+
+	/* init variable */
+	pRXStat = &RXStat;
+	memset(pRXStat, 0, sizeof(RXStat));
+
+	/* reset */
+	if (lt8619c->gpiod_reset) {
+		gpiod_set_value_cansleep(lt8619c->gpiod_reset, 0);
+		usleep_range(5000, 10000);
+	}
+
+	/* check chip ID */
+	if (!lt8619c_check_chipid()) {
+		dev_err(dev, "failed to read LT8619C chip id\n");
+		return 0;
+	}
+
+	lt8619c_poweron();
+
+	if (lt8619c_detect_clk()) {
+		lt8619c_input_info();
+		lt8619c_csc_conversion();
+		lt8619c_check_video();
+		lt8619c_bt_setting();
+		lt8619c_print_rxinfo();
+	}
+
+	dev_info(lt8619c->dev, "LT8619C init done\n");
+
+	return 0;
+}
+
+static int lt8619c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id lt8619c_ids[] = {
+	{ "lt8619c", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lt8619c_ids);
+
+static struct i2c_driver lt8619c_driver = {
+	.driver = {
+		.name = "lontium,lt8619c",
+	},
+	.probe = lt8619c_probe,
+	.remove = lt8619c_remove,
+	.id_table = lt8619c_ids,
+};
+
+static int __init lt8619c_init(void)
+{
+	return i2c_add_driver(&lt8619c_driver);
+}
+/* must be loaded after rk817 mfd driver */
+late_initcall(lt8619c_init);
+
+static void __exit lt8619c_exit(void)
+{
+	i2c_del_driver(&lt8619c_driver);
+}
+module_exit(lt8619c_exit);
+
+MODULE_DESCRIPTION("LT8619C HDMI to LVDS Driver for TFT LCD QC4011");
+MODULE_AUTHOR("Joy Cho <joy.cho@hardkernel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/lt8619c.h b/drivers/media/i2c/lt8619c.h
new file mode 100644
index 000000000000..321bb14c803f
--- /dev/null
+++ b/drivers/media/i2c/lt8619c.h
@@ -0,0 +1,107 @@
+/*
+ * LT8619C HDMI to LVDS converter + TFT-LCD 080-QC4011
+ *
+ * Copyright (C) 2020 Hardkernel Co., Ltd.
+ *
+ * Author : Joy Cho <joy.cho@hardkernel.com>
+ *
+ * The base initial code of this driver is from Lotium semiconductor
+ * and output signal of LT8619C is fixed as following.
+ *    - resolution 1024x768
+ *    - 1 port LVDS
+ *    - 8bit, DE timing mode
+ */
+
+#ifndef __LT8619C_H
+#define __LT8619C_H
+
+#undef USE_EXTERNAL_HDCPKEY
+#undef DDR_CLK
+
+struct video_timing {
+	uint32_t pixel_clk;
+	uint16_t hfp;
+	uint16_t hs;
+	uint16_t hbp;
+	uint16_t hact;
+	uint16_t htotal;
+	uint16_t vfp;
+	uint16_t vs;
+	uint16_t vbp;
+	uint16_t vact;
+	uint16_t vtotal;
+};
+
+enum LT8619C_OUTPUTMODE_ENUM {
+	OUTPUT_RGB888 = 0,
+	OUTPUT_RGB666,
+	OUTPUT_RGB565,
+	OUTPUT_YCBCR444,
+	OUTPUT_YCBCR422_16BIT,
+	OUTPUT_YCBCR422_20BIT,
+	OUTPUT_YCBCR422_24BIT,
+	OUTPUT_BT656_8BIT,
+	OUTPUT_BT656_10BIT,
+	OUTPUT_BT656_12BIT,
+	OUTPUT_BT1120_16BIT,
+	OUTPUT_BT1120_20BIT,
+	OUTPUT_BT1120_24BIT,
+	OUTPUT_LVDS_2_PORT,
+	OUTPUT_LVDS_1_PORT
+};
+
+#define LT8619C_OUTPUTMODE  OUTPUT_RGB888
+
+enum LT8619C_AUDIOINPUT_MODE {
+	I2S_2CH = 0,
+	SPDIF
+};
+
+#define Audio_Input_Mode I2S_2CH
+
+enum {
+	COLOR_RGB = 0x00,
+	COLOR_YCBCR444 = 0x40,
+	COLOR_YCBCR422 = 0x20
+};
+
+#define LT8619C_OUTPUTCOLOR COLOR_RGB
+
+enum {
+	NO_DATA = 0x00,
+	ITU_601 = 0x40,
+	ITU_709 = 0x80,
+	EXTENDED_COLORIETRY = 0xc0
+};
+
+enum {
+	xvYCC601 = 0x00,
+	xvYCC709 = 0x10
+	//FUTURE_COLORIETRY
+};
+
+enum {
+	DEFAULT_RANGE = 0x00,
+	LIMIT_RANGE = 0x04,
+	FULL_RANGE  = 0x08,
+	RESERVED_VAL = 0xc0
+};
+
+struct _LT8619C_RXStatus {
+	bool flag_RXClkStable;
+	bool flag_RXClkDetected;
+	bool flag_RXPLLLocked;
+	bool Flag_HsyncStable;
+	bool input_hdmimode;
+	uint8_t input_vic;
+	uint8_t input_colorspace;
+	uint8_t input_colordepth;
+	uint8_t input_colorimetry;
+	uint8_t input_ex_colorimetry;
+	uint8_t input_QuantRange;
+	uint8_t input_PRfactor;
+	uint8_t input_videoindex;
+	uint32_t ClkFreqValCurrent;
+	uint32_t ClkFreqValPrevious;
+};
+#endif /* __LT8619C_H */
diff --git a/drivers/media/platform/exynos-gsc/gsc-core.h b/drivers/media/platform/exynos-gsc/gsc-core.h
index e894e85e84a4..95fda27de0a3 100644
--- a/drivers/media/platform/exynos-gsc/gsc-core.h
+++ b/drivers/media/platform/exynos-gsc/gsc-core.h
@@ -481,9 +481,9 @@ static inline struct gsc_frame *ctx_get_frame(struct gsc_ctx *ctx,
 {
 	struct gsc_frame *frame;
 
-	if (V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == type) {
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == type || V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == type) {
 		frame = &ctx->s_frame;
-	} else if (V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == type) {
+	} else if (V4L2_BUF_TYPE_VIDEO_CAPTURE == type || V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE == type) {
 		frame = &ctx->d_frame;
 	} else {
 		pr_err("Wrong buffer/video queue type (%d)", type);
diff --git a/drivers/media/platform/s5p-jpeg/jpeg-core.c b/drivers/media/platform/s5p-jpeg/jpeg-core.c
index 7d0ab19c38bb..f1acefdd8bbd 100644
--- a/drivers/media/platform/s5p-jpeg/jpeg-core.c
+++ b/drivers/media/platform/s5p-jpeg/jpeg-core.c
@@ -1785,6 +1785,31 @@ static int exynos3250_jpeg_try_crop(struct s5p_jpeg_ctx *ctx,
  * V4L2 controls
  */
 
+static int vidioc_decoder_cmd(struct file *file, void *priv,
+			struct v4l2_decoder_cmd *cmd)
+{
+	struct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);
+	struct vb2_queue *vq_src = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	struct vb2_v4l2_buffer *buf;
+
+	switch (cmd->cmd) {
+	case V4L2_DEC_CMD_STOP:
+		if (cmd->flags != 0)
+			return -EINVAL;
+		if (!vb2_is_streaming(vq_src))
+			return -EINVAL;
+
+		buf = v4l2_m2m_last_src_buf(ctx->fh.m2m_ctx);
+		buf->flags |= V4L2_BUF_FLAG_LAST;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int s5p_jpeg_g_selection(struct file *file, void *priv,
 			 struct v4l2_selection *s)
 {
@@ -1819,9 +1844,6 @@ static int s5p_jpeg_g_selection(struct file *file, void *priv,
 	return 0;
 }
 
-/*
- * V4L2 controls
- */
 static int s5p_jpeg_s_selection(struct file *file, void *fh,
 				  struct v4l2_selection *s)
 {
@@ -2013,6 +2035,8 @@ static const struct v4l2_ioctl_ops s5p_jpeg_ioctl_ops = {
 	.vidioc_streamon		= v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff		= v4l2_m2m_ioctl_streamoff,
 
+	.vidioc_decoder_cmd             = vidioc_decoder_cmd,
+
 	.vidioc_g_selection		= s5p_jpeg_g_selection,
 	.vidioc_s_selection		= s5p_jpeg_s_selection,
 
@@ -2459,13 +2483,6 @@ static int s5p_jpeg_queue_setup(struct vb2_queue *vq,
 
 	size = q_data->size;
 
-	/*
-	 * header is parsed during decoding and parsed information stored
-	 * in the context so we do not allow another buffer to overwrite it
-	 */
-	if (ctx->mode == S5P_JPEG_DECODE)
-		count = 1;
-
 	*nbuffers = count;
 	*nplanes = 1;
 	sizes[0] = size;
@@ -2573,6 +2590,7 @@ static int s5p_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)
 static void s5p_jpeg_stop_streaming(struct vb2_queue *q)
 {
 	struct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);
+	struct vb2_v4l2_buffer *buf;
 
 	/*
 	 * STREAMOFF is an acknowledgment for resolution change event.
@@ -2585,6 +2603,11 @@ static void s5p_jpeg_stop_streaming(struct vb2_queue *q)
 		ctx->state = JPEGCTX_RUNNING;
 	}
 
+	while ((buf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+	while ((buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx)))
+		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
+
 	pm_runtime_put(ctx->jpeg->dev);
 }
 
@@ -2824,6 +2847,8 @@ static irqreturn_t exynos3250_jpeg_irq(int irq, void *dev_id)
 	v4l2_m2m_buf_done(src_buf, state);
 	if (curr_ctx->mode == S5P_JPEG_ENCODE)
 		vb2_set_plane_payload(&dst_buf->vb2_buf, 0, payload_size);
+	if (src_buf->flags & V4L2_BUF_FLAG_LAST)
+		dst_buf->flags |= V4L2_BUF_FLAG_LAST;
 	v4l2_m2m_buf_done(dst_buf, state);
 
 	curr_ctx->subsampling =
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
index 4c511b026bd7..2cde673cd6c3 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@ -858,7 +858,7 @@ static int s5p_mfc_open(struct file *file)
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -893,7 +893,7 @@ static int s5p_mfc_open(struct file *file)
 	 * We'll do mostly sequential access, so sacrifice TLB efficiency for
 	 * faster allocation.
 	 */
-	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;
+	q->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES | DMA_ATTR_NO_KERNEL_MAPPING;
 	q->mem_ops = &vb2_dma_contig_memops;
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	ret = vb2_queue_init(q);
@@ -941,6 +941,11 @@ static int s5p_mfc_release(struct file *file)
 	mfc_debug_enter();
 	if (dev)
 		mutex_lock(&dev->mfc_mutex);
+
+	/* stop streaming */
+	vb2_streamoff(&ctx->vq_src, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+	vb2_streamoff(&ctx->vq_dst, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+
 	vb2_queue_release(&ctx->vq_src);
 	vb2_queue_release(&ctx->vq_dst);
 	if (dev) {
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
index c1d3bda8385b..16614e26c52c 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
@@ -615,8 +615,8 @@ static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
 	struct s5p_mfc_ctx *ctx = fh_to_ctx(priv);
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err("Call on QBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err("Call on QBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 	if (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		return vb2_qbuf(&ctx->vq_src, NULL, buf);
@@ -635,8 +635,8 @@ static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
 	int ret;
 
 	if (ctx->state == MFCINST_ERROR) {
-		mfc_err_limited("Call on DQBUF after unrecoverable error\n");
-		return -EIO;
+		//mfc_err_limited("Call on DQBUF after unrecoverable error\n");
+		return -EAGAIN;
 	}
 
 	switch (buf->type) {
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
index 3da1775a65f1..e39709736a57 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_enc.c
@@ -1214,6 +1214,7 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 {
 	struct s5p_mfc_dev *dev = ctx->dev;
 	struct s5p_mfc_buf *mb_entry;
+	struct s5p_mfc_buf *dst_buf;
 	unsigned long enc_y_addr = 0, enc_c_addr = 0;
 	unsigned long mb_y_addr, mb_c_addr;
 	int slice_type;
@@ -1234,8 +1235,12 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->src_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
@@ -1248,8 +1253,12 @@ static int enc_post_frame_start(struct s5p_mfc_ctx *ctx)
 					&mb_entry->b->vb2_buf, 0);
 			mb_c_addr = vb2_dma_contig_plane_dma_addr(
 					&mb_entry->b->vb2_buf, 1);
+			dst_buf = list_entry(ctx->dst_queue.next,
+					struct s5p_mfc_buf, list);
 			if ((enc_y_addr == mb_y_addr) &&
 						(enc_c_addr == mb_c_addr)) {
+				dst_buf->b->timecode = mb_entry->b->timecode;
+				dst_buf->b->vb2_buf.timestamp = mb_entry->b->vb2_buf.timestamp;
 				list_del(&mb_entry->list);
 				ctx->ref_queue_cnt--;
 				vb2_buffer_done(&mb_entry->b->vb2_buf,
diff --git a/drivers/mmc/host/dw_mmc-exynos.h b/drivers/mmc/host/dw_mmc-exynos.h
index 0280d394a32a..7088e39de5d2 100644
--- a/drivers/mmc/host/dw_mmc-exynos.h
+++ b/drivers/mmc/host/dw_mmc-exynos.h
@@ -61,7 +61,7 @@
 /* Fixed clock divider */
 #define EXYNOS4210_FIXED_CIU_CLK_DIV	2
 #define EXYNOS4412_FIXED_CIU_CLK_DIV	4
-#define HS400_FIXED_CIU_CLK_DIV		1
+#define HS400_FIXED_CIU_CLK_DIV		2
 
 /* Minimal required clock frequency for cclkin, unit: HZ */
 #define EXYNOS_CCLKIN_MIN	50000000
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 9e8ae4384e4f..3202da470321 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -758,16 +758,23 @@ static int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	if (wol->wolopts) {
 		pr_info("stmmac: wakeup enable\n");
 		device_set_wakeup_enable(priv->device, 1);
-		enable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			enable_irq_wake(priv->wol_irq);
 	} else {
 		device_set_wakeup_enable(priv->device, 0);
-		disable_irq_wake(priv->wol_irq);
+		if (priv->wol_irq != dev->irq)
+			disable_irq_wake(priv->wol_irq);
 	}
 
 	mutex_lock(&priv->lock);
 	priv->wolopts = wol->wolopts;
 	mutex_unlock(&priv->lock);
 
+	if (phy_ethtool_set_wol(dev->phydev, wol) == 0)
+		enable_irq_wake(dev->phydev->irq);
+	else
+		disable_irq_wake(dev->phydev->irq);
+
 	return 0;
 }
 
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 6085a28cae3d..0277cd5410e5 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1779,8 +1779,10 @@ void phy_detach(struct phy_device *phydev)
 	    phy_driver_is_genphy_10g(phydev))
 		device_release_driver(&phydev->mdio.dev);
 
-	/* Assert the reset signal */
-	phy_device_reset(phydev, 1);
+	if (!dev->wol_enabled) {
+		/* Assert the reset signal */
+		phy_device_reset(phydev, 1);
+	}
 
 	/*
 	 * The phydev might go away on the put_device() below, so avoid
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 11be60333fa8..939d99e2767a 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -12,6 +12,7 @@
 #include <linux/phy.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/etherdevice.h>
 
 #define RTL821x_PHYSR				0x11
 #define RTL821x_PHYSR_DUPLEX			BIT(13)
@@ -228,7 +229,13 @@ static int rtl8211f_config_intr(struct phy_device *phydev)
 
 		val = RTL8211F_INER_LINK_STATUS;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
+
+		// Pin 31 -> INTB
+		phy_modify_paged(phydev, 0xd40, 0x16, BIT(5), 0);
 	} else {
+		// Pin 31 -> PMEB
+		phy_modify_paged(phydev, 0xd40, 0x16, 0, BIT(5));
+
 		val = 0;
 		err = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);
 		if (err)
@@ -329,6 +336,34 @@ static int rtl8211c_config_init(struct phy_device *phydev)
 			    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);
 }
 
+static int rtl8211f_set_wol(struct phy_device *phydev,
+		struct ethtool_wolinfo *wol)
+{
+	struct net_device *netdev = phydev->attached_dev;
+	const u8 *mac = (const u8 *)netdev->dev_addr;
+
+	if (wol->wolopts & ~(WAKE_MAGIC | WAKE_UCAST))
+		return -EOPNOTSUPP;
+
+	if (wol->wolopts & WAKE_UCAST) {
+		phy_write_paged(phydev, 0xd8c, 0x10, (mac[1] << 8) | mac[0]);
+		phy_write_paged(phydev, 0xd8c, 0x11, (mac[3] << 8) | mac[2]);
+		phy_write_paged(phydev, 0xd8c, 0x12, (mac[5] << 8) | mac[4]);
+	}
+
+	if (wol->wolopts & WAKE_MAGIC) {
+		/* Set magic packet */
+		phy_write_paged(phydev, 0xd8a, 0x10, 0x1000);
+		phy_write_paged(phydev, 0xd8a, 0x11, 0x9fff);
+	} else {
+		/* Reset magic packet */
+		phy_write_paged(phydev, 0xd8a, 0x10, 0);
+		phy_modify_paged(phydev, 0xd8a, 0x11, BIT(15), 0);
+	}
+
+	return 0;
+}
+
 static int rtl8211f_config_init(struct phy_device *phydev)
 {
 	struct rtl821x_priv *priv = phydev->priv;
@@ -921,6 +956,7 @@ static struct phy_driver realtek_drvs[] = {
 		.handle_interrupt = rtl8211f_handle_interrupt,
 		.suspend	= genphy_suspend,
 		.resume		= rtl821x_resume,
+		.set_wol	= rtl8211f_set_wol,
 		.read_page	= rtl821x_read_page,
 		.write_page	= rtl821x_write_page,
 	}, {
diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c
index ebc67e3ddd4f..9239d4f303cc 100644
--- a/drivers/regulator/s2mps11.c
+++ b/drivers/regulator/s2mps11.c
@@ -1117,6 +1117,57 @@ static const struct regulator_desc s2mpu02_regulators[] = {
 	regulator_desc_s2mpu02_buck7(7),
 };
 
+static int s2mps11_pmic_ethonoff(struct platform_device *pdev, bool onoff)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val = 0;
+	int ret = 0;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L15CTRL value\n");
+		return ret;
+	}
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, &reg_val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read S2MPS11_REG_L17CTRL value\n");
+		return ret;
+	}
+
+	if (onoff) {
+		/* ETH VDD0 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 ON */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0xFF, 0x72);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	} else {
+		/* ETH VDD0 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L15CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL15 register\n");
+			return ret;
+		}
+
+		/* ETH VDD1 OFF */
+		ret = regmap_update_bits(iodev->regmap_pmic, S2MPS11_REG_L17CTRL, 0x3F, 0x00);
+		if (ret) {
+			dev_err(&pdev->dev, "cannot update S2MPS11 LDO CTRL17 register\n");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
 static int s2mps11_pmic_probe(struct platform_device *pdev)
 {
 	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
@@ -1225,6 +1276,34 @@ static int s2mps11_pmic_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void s2mps11_pmic_shutdown(struct platform_device *pdev)
+{
+	struct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);
+	unsigned int reg_val, ret;
+
+	ret = regmap_read(iodev->regmap_pmic, S2MPS11_REG_CTRL1, &reg_val);
+	if (ret < 0) {
+		dev_crit(&pdev->dev, "could not read S2MPS11_REG_CTRL1 value\n");
+	} else {
+		/*
+		 * s2mps11-pmic: S2MPS11_REG_CTRL1 reg value
+		 * is 00000000000000000000000000010000
+		 * clear the S2MPS11_REG_CTRL1 0x10 value to shutdown.
+		 */
+		if (reg_val & BIT(4)) {
+			ret = regmap_update_bits(iodev->regmap_pmic,
+						 S2MPS11_REG_CTRL1,
+						 BIT(4), BIT(0));
+			if (ret)
+				dev_crit(&pdev->dev,
+					 "could not write S2MPS11_REG_CTRL1 value\n");
+		}
+	}
+	s2mps11_pmic_ethonoff(pdev, false);
+	mdelay(10);
+	s2mps11_pmic_ethonoff(pdev, true);
+}
+
 static const struct platform_device_id s2mps11_pmic_id[] = {
 	{ "s2mps11-regulator", S2MPS11X},
 	{ "s2mps13-regulator", S2MPS13X},
@@ -1240,6 +1319,7 @@ static struct platform_driver s2mps11_pmic_driver = {
 		.name = "s2mps11-pmic",
 	},
 	.probe = s2mps11_pmic_probe,
+	.shutdown = s2mps11_pmic_shutdown,
 	.id_table = s2mps11_pmic_id,
 };
 
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 922d778df064..420cc6e894d1 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -691,6 +691,7 @@ static const struct spi_device_id spidev_spi_ids[] = {
 	{ .name = "m53cpld" },
 	{ .name = "spi-petra" },
 	{ .name = "spi-authenta" },
+	{ .name = "spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(spi, spidev_spi_ids);
@@ -705,6 +706,8 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "menlo,m53cpld" },
 	{ .compatible = "cisco,spi-petra" },
 	{ .compatible = "micron,spi-authenta" },
+	/* ODROID Modification */
+	{ .compatible = "odroid,spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/thermal/samsung/exynos_tmu.c b/drivers/thermal/samsung/exynos_tmu.c
index f4ab4c5b4b62..3c6d319063a6 100644
--- a/drivers/thermal/samsung/exynos_tmu.c
+++ b/drivers/thermal/samsung/exynos_tmu.c
@@ -915,8 +915,6 @@ static int exynos_map_dt_data(struct platform_device *pdev)
 	case SOC_ARCH_EXYNOS4412:
 	case SOC_ARCH_EXYNOS5250:
 	case SOC_ARCH_EXYNOS5260:
-	case SOC_ARCH_EXYNOS5420:
-	case SOC_ARCH_EXYNOS5420_TRIMINFO:
 		data->tmu_set_trip_temp = exynos4412_tmu_set_trip_temp;
 		data->tmu_set_trip_hyst = exynos4412_tmu_set_trip_hyst;
 		data->tmu_initialize = exynos4412_tmu_initialize;
@@ -935,6 +933,22 @@ static int exynos_map_dt_data(struct platform_device *pdev)
 			data->min_efuse_value = 0;
 		data->max_efuse_value = 100;
 		break;
+	case SOC_ARCH_EXYNOS5420:
+	case SOC_ARCH_EXYNOS5420_TRIMINFO:
+		data->tmu_set_trip_temp = exynos4412_tmu_set_trip_temp;
+		data->tmu_set_trip_hyst = exynos4412_tmu_set_trip_hyst;
+		data->tmu_initialize = exynos4412_tmu_initialize;
+		data->tmu_control = exynos4210_tmu_control;
+		data->tmu_read = exynos4412_tmu_read;
+		data->tmu_set_emulation = exynos4412_tmu_set_emulation;
+		data->tmu_clear_irqs = exynos4210_tmu_clear_irqs;
+		data->ntrip = 8;
+		data->gain = 8;
+		data->reference_voltage = 16;
+		data->efuse_value = 55;
+		data->min_efuse_value = 16;
+		data->max_efuse_value = 76;
+		break;
 	case SOC_ARCH_EXYNOS5433:
 		data->tmu_set_trip_temp = exynos5433_tmu_set_trip_temp;
 		data->tmu_set_trip_hyst = exynos5433_tmu_set_trip_hyst;
diff --git a/drivers/thermal/thermal_helpers.c b/drivers/thermal/thermal_helpers.c
index ee7027bdcafa..2ee98e68e930 100644
--- a/drivers/thermal/thermal_helpers.c
+++ b/drivers/thermal/thermal_helpers.c
@@ -75,6 +75,10 @@ EXPORT_SYMBOL(get_thermal_instance);
  *
  * Return: On success returns 0, an error code otherwise
  */
+
+#define	CRITICAL_TEMP	120000
+int thermal_zone_data[4] = { 0, };
+
 int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)
 {
 	int ret = -EINVAL;
@@ -108,6 +112,30 @@ int thermal_zone_get_temp(struct thermal_zone_device *tz, int *temp)
 			*temp = tz->emul_temperature;
 	}
 
+	/* save thermal_zone data */
+	if (!ret)
+		thermal_zone_data[tz->id] = *temp;
+	/*
+	 * This case is that the thermal sensor is broken.
+	 * That's not real temperature. Set the fake temperature value in order to
+	 * avoid reaching the ciritical temperature.
+	 */
+	if ((thermal_zone_data[tz->id] > CRITICAL_TEMP) && (tz->id != 4)) {
+		int i, broken_sensor = 0, correct_temp = 0;
+		for (i = 0; i < 4; i++) {
+			if ((thermal_zone_data[i] <= CRITICAL_TEMP) &&
+			    (correct_temp <= thermal_zone_data[i]))
+				correct_temp = thermal_zone_data[i];
+			if (thermal_zone_data[i] > CRITICAL_TEMP)
+				broken_sensor++;
+		}
+		/*
+		 * if all thermal sensor broken then critical temperature data send
+		 * for system poweroff.
+		 */
+		*temp = (broken_sensor == 4) ? CRITICAL_TEMP : correct_temp;
+	}
+
 	mutex_unlock(&tz->lock);
 exit:
 	return ret;
diff --git a/include/drm/drm_mipi_dbi.h b/include/drm/drm_mipi_dbi.h
index 05e194958265..f543d6e3e822 100644
--- a/include/drm/drm_mipi_dbi.h
+++ b/include/drm/drm_mipi_dbi.h
@@ -183,12 +183,7 @@ int mipi_dbi_buf_copy(void *dst, struct drm_framebuffer *fb,
 #define mipi_dbi_command(dbi, cmd, seq...) \
 ({ \
 	const u8 d[] = { seq }; \
-	struct device *dev = &(dbi)->spi->dev;	\
-	int ret; \
-	ret = mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
-	if (ret) \
-		dev_err_ratelimited(dev, "error %d when sending command %#02x\n", ret, cmd); \
-	ret; \
+	mipi_dbi_command_stackbuf(dbi, cmd, d, ARRAY_SIZE(d)); \
 })
 
 #ifdef CONFIG_DEBUG_FS
-- 
2.39.2

